---
title: LLM Rules
description: Authoritative rules for AI assistants working with the Module System
tableOfContents:
  maxHeadingLevel: 2
---

import { Aside, Steps, Tabs, TabItem } from '@astrojs/starlight/components';

This document defines the authoritative rules for AI assistants (Claude, GPT, etc.) working across the Module System. All `CLAUDE.md` files should reference this document for consistent behaviour.

<Aside type="tip">
  Add this to your CLAUDE.md: `For detailed rules, see https://saas.uniqueicon.com.au/getting-started/llm-rules/`
</Aside>

---

## Version Bumping (MANDATORY)

When modifying infrastructure files, you **MUST** bump the version. This is not optional.

### Files That Require Version Bump

**Starter Template:**
```
frontend/src/config/*.ts     # Registry files
frontend/src/lib/*.ts        # Utility libraries
backend/src/config/*.ts      # Registry files
backend/src/lib/*.ts         # Utility libraries
backend/src/middleware/*.ts  # Middleware
create-app.ps1, create-app.sh
update-template.ps1, update-template.sh
scripts/*.ps1, scripts/*.sh
```

**Module Starter:**
```
src/templates/**/*           # Code templates
src/scaffold/**/*            # Scaffold infrastructure
src/config/*.ts              # Configuration
```

**Individual Modules:**
```
src/templates/**/*           # Module templates
src/module.ts                # Module definition
Any file that affects generated output
```

### How to Bump Version

<Tabs>
  <TabItem label="Starter Template">
    ```bash
    # Patch (bug fixes): 1.2.0 → 1.2.1
    npm run template:version:patch

    # Minor (new features): 1.2.0 → 1.3.0
    npm run template:version:minor

    # Major (breaking changes): 1.2.0 → 2.0.0
    npm run template:version:major
    ```
  </TabItem>
  <TabItem label="Modules">
    ```bash
    # Patch
    npm run release:patch

    # Minor
    npm run release:minor

    # Major
    npm run release:major
    ```
  </TabItem>
</Tabs>

### When to Use Each Bump Type

| Type | Use For | Examples |
|------|---------|----------|
| **patch** | Bug fixes, typo corrections, minor tweaks | Fix registry ordering, correct type error |
| **minor** | New features, new registry entries, enhancements | Add new registry, new middleware, new template |
| **major** | Breaking changes to APIs or interfaces | Change registry interface, rename exports |

### Version Bump Workflow

<Steps>
1. Make your changes to the infrastructure files
2. Run the appropriate version bump command
3. Commit the version bump in the same commit (or immediately after)
4. The bump script handles VERSION file, package.json, and module.ts automatically
</Steps>

<Aside type="caution">
  Never skip version bumping. Apps use version numbers to track template updates. Missing version bumps break the update system.
</Aside>

---

## Documentation Changes (MANDATORY)

When editing documentation files in the `docs/` folder, you **MUST** push your changes. The docs folder is a git submodule.

### Why This Matters

- Pushing triggers automatic deployment to https://saas.uniqueicon.com.au
- If you don't push, the live documentation won't update
- The submodule reference in the parent repo must also be updated

### Documentation Workflow

<Steps>
1. Make your changes to files in `docs/src/content/docs/`
2. Commit in the submodule: `cd docs && git add . && git commit -m "Docs: description"`
3. **Push the submodule**: `git push`
4. Update parent repo: `cd .. && git add docs && git commit -m "Update docs submodule"`
</Steps>

### Checklist After Editing Docs

- [ ] Changes committed in `docs/` submodule
- [ ] Submodule pushed (`git push` from docs folder)
- [ ] Submodule reference updated in parent repo (`git add docs && git commit`)

<Aside type="caution">
  Never leave docs changes unpushed. The live site won't update until you push.
</Aside>

---

## Spelling Conventions

This codebase uses **Australian spelling** in prose and **American spelling** in code.

### Australian Spelling (Documentation & Comments)

Use Australian/British spelling in:
- Documentation files (`.mdx`, `.md`)
- Code comments
- UI text and labels
- Error messages shown to users

| American | Australian (Use This) |
|----------|----------------------|
| color | colour |
| behavior | behaviour |
| organization | organisation |
| customize | customise |
| center | centre |
| canceled | cancelled |

### American Spelling (Code)

Use American spelling in:
- Variable names
- Function names
- CSS properties (they're American by spec)
- Technical terms from libraries

```typescript
// Comment uses Australian spelling
// This function customises the colour scheme

// Code uses American spelling (follows JS conventions)
const backgroundColor = theme.colors.primary;
function customizeSettings() { ... }
```

---

## Backend Import Rules

### Always Use .js Extension

In backend TypeScript files, **always** use `.js` extensions for relative imports:

```typescript
// ✅ Correct
import { prisma } from '../../lib/prisma.js';
import { NotFoundError } from '../../lib/errors.js';
import { userService } from './user.service.js';

// ❌ Wrong - will fail at runtime
import { prisma } from '../../lib/prisma';
import { NotFoundError } from '../../lib/errors';
```

### Why .js Extensions?

TypeScript compiles to JavaScript. Node.js ESM requires explicit file extensions. The `.js` extension refers to the compiled output, not the source file.

### Type-Only Imports

Use the `type` keyword for type-only imports:

```typescript
import type { Request, Response } from 'express';
import type { UserProfile } from './user.types.js';
```

---

## Critical System Knowledge

### Authentication

**Neon Auth URL must match EXACTLY** between frontend and backend, including the full path:

```env
# Both must be identical
VITE_NEON_AUTH_URL=https://xxx.neonauth.region.aws.neon.tech/neondb/auth
NEON_AUTH_URL=https://xxx.neonauth.region.aws.neon.tech/neondb/auth
```

JWKS endpoint for token validation: `<NEON_AUTH_URL>/.well-known/jwks.json`

### Database URLs

Neon requires **two** database URLs:

| Variable | Has `-pooler` | Use For |
|----------|--------------|---------|
| `DATABASE_URL` | Yes | App queries (pooled connections) |
| `DIRECT_DATABASE_URL` | No | Migrations only (direct connection) |

```env
# Pooled - for app queries
DATABASE_URL="postgresql://user:pass@ep-xxx-pooler.region.aws.neon.tech/neondb"

# Direct - for migrations
DIRECT_DATABASE_URL="postgresql://user:pass@ep-xxx.region.aws.neon.tech/neondb"
```

### Database Migrations

Always use `prisma migrate dev` for schema changes, never `db push`:

```bash
cd backend && npx prisma migrate dev --name describe_change
```

---

## Registry System

### Naming Conventions

All registries extend `BaseRegistry<T>`. Use the correct type names:

| Registry | Item Type | Hook |
|----------|-----------|------|
| `navigationRegistry` | `NavigationItem` | `useNavigationRegistry()` |
| `dashboardRegistry` | `DashboardWidget` | `useDashboardRegistry()` |
| `settingsPagesRegistry` | `SettingsPage` | `useSettingsPagesRegistry()` |
| `headerToolbarRegistry` | `HeaderToolbarItem` | `useHeaderToolbarRegistry()` |
| `adminPagesRegistry` | `AdminPage` | `useAdminPages()` |

<Aside type="caution">
  Use `NavigationItem`, not `NavItem`. Use the full type names as defined in the registry files.
</Aside>

### Order Values

Use consistent order ranges across all registries:

| Range | Use For |
|-------|---------|
| 1-9 | Core/system items |
| 10-29 | Primary features (Dashboard, Home) |
| 30-49 | Main features |
| 50-69 | Secondary features |
| 70-89 | Settings, admin |
| 90-99 | Footer items, logout |
| 100+ | Third-party plugins |

**Lower numbers = appears first / runs first**

### Self-Registration Pattern

Features register via side-effect imports. **Never modify core files** (`routes.tsx`, `app.ts`) directly for new features:

```typescript
// features/my-feature/index.ts
// Side-effect imports trigger registration
import './navigation.registration';
import './route.registration';

// Named exports
export { MyFeaturePage } from './pages/MyFeaturePage';
```

### Creating Registrations

Always create a separate registration file:

```typescript
// features/my-feature/navigation.registration.ts
import { navigationRegistry } from '@/config/navigation.registry';
import { MyIcon } from 'lucide-react';

navigationRegistry.registerMain({
  id: 'my-feature',
  title: 'My Feature',
  url: '/my-feature',
  icon: MyIcon,
  order: 30,
});
```

---

## Code Conventions

### File Headers

**Every file** must have a header comment:

```typescript
// ========================================================================
// FILE: [path/from/repo/root]
// PURPOSE: [one-line description]
// DESCRIPTION: [optional longer description for complex files]
// ========================================================================
```

### Section Dividers

Use section dividers for logical groupings:

```typescript
// ========================================================================
// TYPES
// ========================================================================

interface MyType { ... }

// ========================================================================
// REGISTRY
// ========================================================================

export const myRegistry = new BaseRegistry<MyType>('my-registry');
```

### Import Order

Always order imports:

1. External packages (react, express, etc.)
2. Internal absolute imports (`@/...`)
3. Relative imports (`./`, `../`)

```typescript
// External
import { useState } from 'react';
import { Router } from 'express';

// Internal absolute
import { api } from '@/lib/api';
import { useUserProfile } from '@/features/user';

// Relative
import { MyComponent } from './components/MyComponent';
import type { MyType } from './types';
```

### Naming Conventions

| Item | Convention | Example |
|------|------------|---------|
| Files | kebab-case | `user-profile.tsx`, `auth.middleware.ts` |
| Components | PascalCase | `UserProfile`, `DashboardWidget` |
| Functions | camelCase | `getUserProfile`, `handleSubmit` |
| Constants | SCREAMING_SNAKE | `API_BASE_URL`, `MAX_RETRIES` |
| Types/Interfaces | PascalCase | `UserProfile`, `RegistryItem` |
| Registry files | `*.registry.ts` | `navigation.registry.ts` |
| Registration files | `*.registration.ts` | `navigation.registration.ts` |

### TypeScript

- **Always** use TypeScript types - no `any` unless absolutely necessary
- Prefer `interface` over `type` for object shapes
- Export types that are used across files
- Use `unknown` instead of `any` when type is truly unknown

---

## Feature Architecture

### Frontend Feature Structure

```
frontend/src/features/[feature]/
├── index.ts                    # Public exports + registration imports
├── routes.config.tsx           # Route definitions
├── navigation.registration.ts  # Navigation registry registration
├── components/                 # Feature components
│   └── MyComponent.tsx
├── pages/                      # Page components
│   └── MyFeaturePage.tsx
├── services/                   # API service layer
│   └── my-feature.service.ts
├── hooks/                      # Custom hooks
│   └── useMyFeature.ts
└── types/                      # TypeScript types
    └── index.ts
```

### Backend Feature Structure

```
backend/src/features/[feature]/
├── index.ts                    # Exports + registration imports
├── [feature].routes.ts         # Express routes
├── [feature].service.ts        # Business logic
├── [feature].types.ts          # Types
├── route.registration.ts       # Route registry registration
└── service.registration.ts     # Service registry registration
```

### What Goes Where

| Code Type | Location |
|-----------|----------|
| Business logic | Services (`*.service.ts`) |
| HTTP handling | Routes (`*.routes.ts`) |
| Data fetching | Hooks (`hooks/`) |
| UI components | Components (`components/`) |
| Page layouts | Pages (`pages/`) |
| Types | Types (`types/`) or colocated |

---

## Common Mistakes to Avoid

| Mistake | Correct Approach |
|---------|------------------|
| Missing `.js` in backend imports | Always use `.js` extension: `import { x } from './file.js'` |
| Using old type names (`NavItem`) | Use `NavigationItem` (full names from registry) |
| Editing `components/ui/` | Never edit shadcn files - regenerate instead |
| Modifying `routes.tsx` for new features | Use registration files and side-effect imports |
| Using `db push` for schema changes | Use `prisma migrate dev` |
| Hardcoding URLs | Use environment variables |
| Creating files without checking structure | Follow the exact feature structure |
| American spelling in docs | Use Australian spelling in documentation |
| Forgetting to push docs | Always push docs submodule after changes |

---

## Error Handling

### Backend Errors

Use HTTP-aware errors from `lib/errors.ts`:

```typescript
import { NotFoundError, UnauthorizedError, BadRequestError } from '../../lib/errors.js';

// 404 - Resource not found
if (!item) {
  throw new NotFoundError('Item not found');
}

// 401 - Authentication required (use for security to prevent enumeration)
if (!user) {
  throw new UnauthorizedError('Unauthorized');
}

// 400 - Bad request
if (!isValid) {
  throw new BadRequestError('Invalid input');
}
```

### Available Error Classes

| Error | Code | Use For |
|-------|------|---------|
| `BadRequestError` | 400 | Invalid input |
| `UnauthorizedError` | 401 | Auth required |
| `ForbiddenError` | 403 | Permission denied |
| `NotFoundError` | 404 | Resource not found |
| `ConflictError` | 409 | Duplicate/conflict |
| `TooManyRequestsError` | 429 | Rate limiting |
| `InternalError` | 500 | Server error |
| `ServiceUnavailableError` | 503 | Service down |

---

## Database Operations

### Always Use Prisma Client from lib

```typescript
import { prisma } from '../../lib/prisma.js';

export async function getItems(userId: string) {
  return prisma.item.findMany({ where: { userId } });
}
```

### Use Transactions for Multi-Table Operations

```typescript
import { withTransaction } from '../../lib/prisma.js';

const result = await withTransaction(async (tx) => {
  const user = await tx.user.create({ data: { ... } });
  const settings = await tx.settings.create({ data: { userId: user.id } });
  return { user, settings };
});
```

### User Routes Pattern

Always use `getOrCreateProfile` to ensure user exists:

```typescript
router.get('/profile', requireAuth, async (req, res) => {
  const profile = await userService.getOrCreateProfile(req.user!.id, req.user!.email);
  res.json(profile);
});
```

---

## Do and Don't

### DO

- ✅ Follow the feature-based architecture
- ✅ Use the registry pattern for extensibility
- ✅ Add file headers to all files
- ✅ Use section dividers for organisation
- ✅ Use the `api` client for frontend API calls
- ✅ Use `getOrCreateProfile` pattern in backend routes
- ✅ Match environment variable names exactly
- ✅ Use side-effect imports for registrations
- ✅ Use registry hooks for reactive updates
- ✅ Bump version when modifying infrastructure files
- ✅ Push docs after editing documentation
- ✅ Use named exports (not default exports)
- ✅ Use `cn()` utility for conditional classNames
- ✅ Use `.js` extensions in backend imports
- ✅ Use Australian spelling in documentation

### DON'T

- ❌ Modify `components/ui/` directly (shadcn components - regenerate instead)
- ❌ Put business logic in route handlers (use services)
- ❌ Hardcode URLs (use environment variables)
- ❌ Skip TypeScript types
- ❌ Create files without header comments
- ❌ Commit `.env` files
- ❌ Manually wire navigation (use registries)
- ❌ Use `any` type without good reason
- ❌ Create documentation files unless explicitly requested
- ❌ Use emojis in code unless explicitly requested
- ❌ Modify core files (`routes.tsx`, `app.ts`) directly for features
- ❌ Use `db push` instead of `migrate dev`
- ❌ Leave docs changes unpushed

---

## Git Commit Messages

### Format

```
type(scope): description

[optional body]

Co-Authored-By: Claude <assistant> (if AI assisted)
```

### Types

| Type | Use For |
|------|---------|
| `feat` | New feature |
| `fix` | Bug fix |
| `docs` | Documentation only |
| `style` | Formatting, no code change |
| `refactor` | Code change that doesn't fix bug or add feature |
| `perf` | Performance improvement |
| `test` | Adding tests |
| `chore` | Maintenance tasks |

### Examples

```
feat(billing): add subscription management page

fix(auth): resolve token refresh race condition

chore(deps): update Prisma to v6.0
```

---

## Testing Checklist

Before considering work complete, verify:

- [ ] TypeScript compiles: `npm run type-check`
- [ ] Frontend runs: `npm run dev:frontend`
- [ ] Backend runs: `npm run dev:backend`
- [ ] Auth works: Can sign in/out
- [ ] API works: No 401 errors in console
- [ ] Routes work: Navigation to new pages works
- [ ] Registrations work: Items appear in correct locations
- [ ] Version bumped (if infrastructure files changed)
- [ ] Docs pushed (if documentation changed)

---

## Module-Specific Rules

### When Working on Modules

1. **Check module.ts** - Understand what the module provides
2. **Check templates/** - See what code gets generated
3. **Follow starter template patterns** - Modules extend, not replace
4. **Update module version** - When changing templates or module.ts

### Module Integration Points

Modules typically register with:

| Registry | Purpose |
|----------|---------|
| `navigationRegistry` | Add menu items |
| `settingsPagesRegistry` | Add settings pages |
| `dashboardRegistry` | Add dashboard widgets |
| `routeRegistry` | Add API endpoints |
| `serviceRegistry` | Expose services to other features |

---

## Shell Script Rules

When working on `create-app.*` or `update-template.*` scripts, follow these rules:

### Cross-Platform Sync

**Always update both versions**: Changes to `.ps1` files must be mirrored in `.sh` files (and vice versa).

### Git Commands in Scripts

**Always use `--no-pager`** for git display commands to prevent scripts from hanging:

```bash
# ✅ Correct
git --no-pager log --oneline
git --no-pager diff --stat

# ❌ Wrong - opens pager, blocks script
git log --oneline
git diff --stat
```

### File Content from Git

**Use `git checkout`, not `git show`** to write files from git history. `git show` + variable assignment loses newlines:

```bash
# ✅ Correct - preserves exact content
git checkout "remote/branch" -- filename

# ❌ Wrong - loses newlines, corrupts files
CONTENT=$(git show "remote/branch:file")
echo "$CONTENT" > file
```

### Self-Updating Scripts

When a script updates itself:

1. Use `git checkout` to get new version (not `git show`)
2. Immediately `git add` and `git commit` the change
3. `git push` before re-executing
4. Wait 2 seconds after push
5. Save original arguments before parsing (`ORIGINAL_ARGS=("$@")`)
6. Re-execute with `exec "$0" "${ORIGINAL_ARGS[@]}"`

### PowerShell Unused Variables

Use redirection to avoid PSScriptAnalyzer warnings:

```powershell
# ✅ Correct
git rev-parse --is-inside-work-tree >$null 2>&1

# ❌ Wrong - triggers unused variable warning
$null = git rev-parse --is-inside-work-tree
```

### Template-Only Files

These files should be auto-removed during merge to apps:

- `create-app.ps1`, `create-app.sh`, `create-app.bat`
- Template-specific docs

Detect via `git ls-files --unmerged` and remove during conflict handling.

### Script Modification Checklist

- [ ] Updated both `.ps1` AND `.sh` versions?
- [ ] Using `git checkout` (not `git show`) for file updates?
- [ ] Using `--no-pager` for git display commands?
- [ ] Self-update commits AND pushes before re-executing?
- [ ] Delay after push before re-execute?
- [ ] VERSION file bumped?
- [ ] Template-only files in auto-remove list?

---

## Quick Reference

### Common Commands

```bash
# Development
npm run dev                    # Run both frontend and backend
npm run dev:frontend           # Frontend only
npm run dev:backend            # Backend only

# Type checking
npm run type-check             # Check TypeScript

# Database
cd backend && npx prisma studio        # Open database GUI
cd backend && npx prisma migrate dev   # Run migrations
cd backend && npx prisma generate      # Regenerate client

# Versioning (starter template)
npm run template:version:patch
npm run template:version:minor
npm run template:version:major

# Versioning (modules)
npm run release:patch
npm run release:minor
npm run release:major

# Add shadcn component
cd frontend && npx shadcn@latest add [component]
```

### Environment Variables

| Variable | Location | Purpose |
|----------|----------|---------|
| `VITE_NEON_AUTH_URL` | frontend/.env | Auth endpoint |
| `VITE_API_URL` | frontend/.env | Backend URL |
| `DATABASE_URL` | backend/.env | Pooled DB connection (has `-pooler`) |
| `DIRECT_DATABASE_URL` | backend/.env | Direct DB for migrations (no `-pooler`) |
| `NEON_AUTH_URL` | backend/.env | JWT validation (must match frontend) |
| `PORT` | backend/.env | Backend port |
| `FRONTEND_URL` | backend/.env | CORS origin |

---

## Referencing These Rules

In your CLAUDE.md, add:

```markdown
## LLM Rules Reference

For comprehensive rules on code conventions, versioning, and patterns, see:
**https://saas.uniqueicon.com.au/getting-started/llm-rules/**

**Critical rules to always follow:**
1. **Bump version** when modifying infrastructure files (config/, lib/, middleware/, scripts/)
2. **Push docs** after editing documentation (triggers deploy)
3. **Add file headers** to all new files
4. **Use the registry pattern** for extensibility
5. **Follow feature-based architecture**
```
