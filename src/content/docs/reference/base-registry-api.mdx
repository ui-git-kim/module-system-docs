---
title: BaseRegistry API
description: Complete API reference for the BaseRegistry abstract class and utility functions
sidebar:
  order: 4
---

import { Aside } from '@astrojs/starlight/components';

The `BaseRegistry<T>` class is the foundation for all collection-based registries in the starter template. It provides item storage, ordering, duplicate detection, and React subscription support via `useSyncExternalStore`.

**Import path:** `@/config/base.registry`

---

## RegistryItem Interface

All items stored in a `BaseRegistry` must extend this base interface:

```typescript
interface RegistryItem {
  /** Unique identifier for this item */
  id: string;
  /** Sort order (lower = appears first). Default varies by registry */
  order?: number;
}
```

---

## RegistrationOptions Interface

Options that control how `register()` behaves:

```typescript
interface RegistrationOptions {
  /** Allow replacing an existing item with the same ID. Default: false */
  allowReplace?: boolean;
  /** Suppress console warning on duplicate ID. Default: false */
  silent?: boolean;
}
```

---

## Class Signature

```typescript
abstract class BaseRegistry<T extends RegistryItem> {
  constructor(registryName: string, defaultOrder?: number);
}
```

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `registryName` | `string` | — | Name used in console warnings and errors |
| `defaultOrder` | `number` | `10` | Default order for items that don't specify one |

---

## Registration Methods

### register(item, options?)

Register a single item. Returns `true` if registered, `false` if skipped (duplicate ID without `allowReplace`).

```typescript
register(item: T, options?: RegistrationOptions): boolean
```

```typescript
registry.register({
  id: 'my-widget',
  title: 'My Widget',
  order: 30,
  component: MyWidget,
});

// Replace an existing item
registry.register(updatedItem, { allowReplace: true });
```

### registerMany(items, options?)

Register multiple items in a batch. Notifies listeners only once after all items are added. Returns the number of items successfully registered.

```typescript
registerMany(items: T[], options?: RegistrationOptions): number
```

```typescript
const count = registry.registerMany([item1, item2, item3]);
// Triggers a single re-render, not three
```

### unregister(id)

Remove an item by ID. Returns `true` if removed, `false` if not found.

```typescript
unregister(id: string): boolean
```

```typescript
registry.unregister('my-widget');
```

### unregisterMany(ids)

Remove multiple items by ID. Notifies listeners once. Returns the number of items removed.

```typescript
unregisterMany(ids: string[]): number
```

```typescript
registry.unregisterMany(['widget-a', 'widget-b']);
```

### clear()

Remove all registered items. Useful for testing.

```typescript
clear(): void
```

---

## Retrieval Methods

### get(id)

Get a single item by ID, or `undefined` if not found.

```typescript
get(id: string): T | undefined
```

```typescript
const widget = dashboardRegistry.get('analytics-overview');
if (widget) {
  console.log(widget.title);
}
```

### getAll()

Get all registered items, sorted by `order` (ascending). Returns a new array copy each time.

```typescript
getAll(): T[]
```

```typescript
const allWidgets = dashboardRegistry.getAll();
```

### has(id)

Check if an item with the given ID exists.

```typescript
has(id: string): boolean
```

```typescript
if (navigationRegistry.has('billing')) {
  // Billing module is installed
}
```

### count()

Get the number of registered items.

```typescript
count(): number
```

### getIds()

Get all registered item IDs.

```typescript
getIds(): string[]
```

---

## Subscription Methods (React Integration)

These methods implement the `useSyncExternalStore` contract, enabling registries to drive reactive React rendering.

### subscribe(listener)

Subscribe to registry changes. Returns an unsubscribe function.

```typescript
subscribe(listener: () => void): () => void
```

```typescript
const unsubscribe = registry.subscribe(() => {
  console.log('Registry changed');
});

// Later: unsubscribe();
```

### getSnapshot()

Get a stable array reference for `useSyncExternalStore`. Returns the **same** array reference until the registry changes, avoiding unnecessary re-renders.

```typescript
getSnapshot(): T[]
```

---

## Protected Methods

These are available to subclasses that extend `BaseRegistry`:

### updateSnapshot()

Rebuilds the cached snapshot (sorted array). Called automatically after any mutation. Override this to customise sorting behaviour.

```typescript
protected updateSnapshot(): void
```

### notifyListeners()

Notifies all subscribed listeners of a change. Called automatically after mutations.

```typescript
protected notifyListeners(): void
```

---

## createRegistryHook Utility

Creates a React hook for any registry instance. The hook automatically re-renders components when items are added or removed.

```typescript
function createRegistryHook<T extends RegistryItem>(
  registry: BaseRegistry<T>
): () => T[]
```

```typescript
import { createRegistryHook } from '@/config/base.registry';

const myRegistry = new MyRegistry();
export const useMyRegistry = createRegistryHook(myRegistry);

// In a component:
function MyComponent() {
  const items = useMyRegistry();
  return items.map(item => <div key={item.id}>{item.title}</div>);
}
```

---

## Creating a Custom Registry

### Step 1: Define the Item Interface

```typescript
import { type RegistryItem } from '@/config/base.registry';
import type { ComponentType } from 'react';

export interface NotificationChannel extends RegistryItem {
  id: string;
  name: string;
  icon: ComponentType<{ className?: string }>;
  component: ComponentType;
  order?: number;
}
```

### Step 2: Create the Registry Class

```typescript
import { BaseRegistry, createRegistryHook } from '@/config/base.registry';

class NotificationChannelRegistry extends BaseRegistry<NotificationChannel> {
  constructor() {
    super('NotificationChannelRegistry', 50);
  }

  // Add custom methods
  getByName(name: string): NotificationChannel | undefined {
    return this.getAll().find(ch => ch.name === name);
  }
}
```

### Step 3: Export Singleton and Hook

```typescript
export const notificationChannelRegistry = new NotificationChannelRegistry();
export const useNotificationChannels = createRegistryHook(notificationChannelRegistry);
```

### Step 4: Use in Modules

```typescript
// features/slack/notification-channel.registration.ts
import { notificationChannelRegistry } from '@/config/notification-channel.registry';
import { SlackNotificationConfig } from './components/SlackNotificationConfig';
import { Slack } from 'lucide-react';

notificationChannelRegistry.register({
  id: 'slack',
  name: 'Slack',
  icon: Slack,
  component: SlackNotificationConfig,
  order: 20,
});
```

---

## Order Convention

All registries follow a consistent ordering convention. Lower numbers appear first.

| Range | Purpose |
|-------|---------|
| 1–9 | Core/system items |
| 10 | Default order |
| 11–49 | Early feature items |
| 50–99 | Standard feature items |
| 100+ | Third-party/plugin items |

<Aside type="tip">
  Individual registries may define more specific conventions (e.g., settings pages use 10–20 for core user pages, 81–90 for data/privacy). Check the registry source file for details.
</Aside>

---

## Best Practices

- **Unique IDs** — Use feature-namespaced IDs to avoid collisions (e.g., `billing-subscription`, not `subscription`)
- **Order values** — Respect the convention ranges. Modules should use 50+ unless they need to appear early
- **Batch operations** — Use `registerMany()` when registering multiple items to avoid multiple re-renders
- **Optional access** — Use `has()` before `get()` if the item may not exist
- **Testing** — Use `clear()` in test setup to reset state
