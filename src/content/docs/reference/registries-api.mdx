---
title: Registries API Reference
description: Complete API reference for all built-in frontend and backend registries
sidebar:
  order: 3
---

import { Aside } from '@astrojs/starlight/components';

Quick reference for every registry in the system. For conceptual documentation, see [Registry Reference](/starter-template/registries/). For the base class API, see [BaseRegistry API](/reference/base-registry-api/).

---

## Frontend Collection Registries

All collection registries extend `BaseRegistry<T>` and inherit its methods (`register`, `unregister`, `get`, `getAll`, `has`, `count`, `getIds`, `clear`). Only registry-specific additions are documented here.

---

### navigationRegistry

**Import:** `@/config/navigation.registry`

**Item type:** `NavigationItem`

```typescript
interface NavigationItem extends RegistryItem {
  id: string;
  section: 'main' | 'secondary' | 'user';
  sidebarSection?: string;          // For main items only. Default: 'main'
  title: string;
  url?: string;                     // Optional for user menu onClick items
  icon: LucideIcon;
  order?: number;                   // Default: 50
  badge?: string | number;
  requiredRole?: UserRole | UserRole[];
  items?: { title: string; url: string }[];  // Sub-navigation
  onClick?: () => void;             // User menu action
  separator?: boolean;              // Separator before (user menu only)
  external?: boolean;               // Open in new tab
}
```

**Convenience input types:**

| Type | For | Required fields |
|------|-----|-----------------|
| `MainNavItem` | `registerMain()` | `url` required |
| `SecondaryNavItem` | `registerSecondary()` | `url` required |
| `UserMenuItem` | `registerUserMenu()` | `url` or `onClick` |

**Registration methods:**

```typescript
navigationRegistry.registerMain(item: MainNavItem): boolean
navigationRegistry.registerSecondary(item: SecondaryNavItem): boolean
navigationRegistry.registerUserMenu(item: UserMenuItem): boolean
navigationRegistry.registerSection(section: SidebarSection): boolean
navigationRegistry.registerFeature(config: {
  sections?: SidebarSection[];
  main?: MainNavItem[];
  secondary?: SecondaryNavItem[];
  userMenu?: UserMenuItem[];
}): void
```

**Retrieval methods:**

```typescript
navigationRegistry.getMain(): NavigationItem[]
navigationRegistry.getSecondary(): NavigationItem[]
navigationRegistry.getUserMenu(): NavigationItem[]
navigationRegistry.getGrouped(): { main, secondary, user }
navigationRegistry.getMainGroupedBySection(): Map<string, NavigationItem[]>
navigationRegistry.getSections(): SidebarSection[]
navigationRegistry.getSection(id: string): SidebarSection | undefined
navigationRegistry.hasSection(id: string): boolean
```

**SidebarSection interface:**

```typescript
interface SidebarSection {
  id: string;
  label: string;
  showLabel: boolean;
  order?: number;   // Default: 50
}
```

**Hooks:**

| Hook | Returns |
|------|---------|
| `useNavigationRegistry()` | `NavigationItem[]` |
| `useNavigationGrouped()` | `{ main, secondary, user }` |
| `useMainNavigation()` | `NavigationItem[]` |
| `useMainNavigationGrouped()` | `Map<string, NavigationItem[]>` |
| `useSecondaryNavigation()` | `NavigationItem[]` |
| `useUserMenuNavigation()` | `NavigationItem[]` |
| `useRegistrySections()` | `SidebarSection[]` |

---

### dashboardRegistry

**Import:** `@/config/dashboard.registry`

**Item type:** `DashboardWidget`

```typescript
interface DashboardWidget extends RegistryItem {
  id: string;
  title: string;
  component: ComponentType<DashboardWidgetProps>;
  size: '1x1' | '2x1' | '1x2' | '2x2' | 'full';
  order?: number;           // Default: 10
  category?: string;
  description?: string;
  canHide?: boolean;        // Default: true
  canResize?: boolean;      // Default: false
  minRole?: string;
}

interface DashboardWidgetProps {
  widget: DashboardWidget;
  isCompact?: boolean;
}
```

**Additional methods:**

```typescript
dashboardRegistry.getByCategory(category: string): DashboardWidget[]
dashboardRegistry.getCategories(): string[]
dashboardRegistry.getVisible(userVisibility?: WidgetVisibility[]): DashboardWidget[]
```

**Hooks:**

| Hook | Returns |
|------|---------|
| `useDashboardRegistry()` | `DashboardWidget[]` |
| `useVisibleDashboardWidgets(prefs?)` | `DashboardWidget[]` |

**CSS utilities:**

```typescript
WIDGET_SIZE_CLASSES: Record<WidgetSize, string>
// '1x1' → 'col-span-1 row-span-1', '2x1' → 'col-span-2 row-span-1', etc.

DASHBOARD_GRID_CLASSES: string
// 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 auto-rows-min'
```

---

### settingsPagesRegistry

**Import:** `@/config/settings-pages.registry`

**Item type:** `SettingsPage`

```typescript
interface SettingsPage extends RegistryItem {
  id: string;                // Used in URL: /settings/{id}
  title: string;
  description?: string;
  icon: ComponentType<{ className?: string }> | LucideIcon;
  component: ComponentType;  // Automatically wrapped in SettingsLayout
  order?: number;            // Default: 100
  showInNav?: boolean;       // Default: true
  isReplacement?: boolean;   // Default: false
}
```

**Additional methods:**

```typescript
settingsPagesRegistry.getAllForNav(): SettingsPage[]
settingsPagesRegistry.getComponent(id: string): ComponentType | null
settingsPagesRegistry.getPageInfo(id: string): SettingsPageInfo | null
settingsPagesRegistry.hasReplacement(id: string): boolean
```

**Constants:**

```typescript
REPLACEABLE_PAGE_IDS: readonly ['billing']
NON_EXTENSIBLE_PAGE_IDS: readonly ['security', 'data']
```

**Hooks:**

| Hook | Returns |
|------|---------|
| `useSettingsPagesRegistry()` | `SettingsPage[]` |
| `useSettingsNavigation()` | `{ title, url, icon, order }[]` |

---

### headerToolbarRegistry

**Import:** `@/config/header-toolbar.registry`

**Item type:** `ToolbarItem`

```typescript
type ToolbarItemType = 'action' | 'toggle' | 'dropdown' | 'button' | 'search' | 'custom';
type ToolbarPosition = 'left' | 'right';

interface ToolbarItem extends RegistryItem {
  id: string;
  type: ToolbarItemType;
  position: ToolbarPosition;
  order?: number;
  icon?: LucideIcon;
  label?: string;
  badge?: string | number;
  separatorBefore?: boolean;
  onClick?: () => void;
  isActive?: boolean | (() => boolean);
  component?: ComponentType<ToolbarItemComponentProps>;
  isVisible?: () => boolean;
  disabled?: boolean | (() => boolean);
  // Button type:
  buttonLabel?: string;
  buttonVariant?: 'default' | 'secondary' | 'destructive' | 'outline' | 'ghost';
  buttonSize?: 'default' | 'sm' | 'lg';
  isLoading?: boolean | (() => boolean);
  // Search type:
  placeholder?: string;
  onSearch?: (value: string) => void;
  searchValue?: string | (() => string);
}
```

**Additional methods:**

```typescript
headerToolbarRegistry.update(id: string, updates: Partial<Omit<ToolbarItem, 'id'>>): void
headerToolbarRegistry.getByPosition(position: ToolbarPosition): ToolbarItem[]
headerToolbarRegistry.getGrouped(): { left: ToolbarItem[]; right: ToolbarItem[] }
```

**Hooks:**

| Hook | Returns |
|------|---------|
| `useHeaderToolbarRegistry()` | `ToolbarItem[]` |
| `useHeaderToolbarGrouped()` | `{ left, right }` |

---

### adminPagesRegistry

**Import:** `@/config/admin-pages.registry`

**Item type:** `AdminPage`

```typescript
interface AdminPage extends RegistryItem {
  id: string;
  title: string;
  description?: string;
  icon: LucideIcon;
  component: ComponentType;
  order?: number;
  badge?: string | number;
}
```

**Additional methods:**

```typescript
adminPagesRegistry.getNavItems(): Array<{
  id: string;
  title: string;
  url: string;          // Computed: /admin/{id}
  icon: LucideIcon;
  description?: string;
  badge?: string | number;
}>
```

**Hook:** `useAdminPages()` → `AdminPage[]`

---

### preferencesRegistry

**Import:** `@/config/preferences.registry`

**Item type:** `PreferenceSection`

```typescript
interface PreferenceSection extends RegistryItem {
  id: string;
  title: string;
  component: ComponentType;
  order?: number;
}
```

**Hook:** `usePreferencesRegistry()` → `PreferenceSection[]`

---

### integrationsRegistry

**Import:** `@/config/integrations.registry`

**Item type:** `Integration`

```typescript
type IntegrationCategory = 'storage' | 'communication' | 'productivity' | 'developer' | 'social' | 'other';

interface Integration extends RegistryItem {
  id: string;
  name: string;
  description: string;
  icon: ComponentType<{ className?: string }> | LucideIcon;
  category: IntegrationCategory;
  component: ComponentType;
  order?: number;
}
```

**Additional methods:**

```typescript
integrationsRegistry.getByCategory(category: IntegrationCategory): Integration[]
integrationsRegistry.getGrouped(): Map<IntegrationCategoryInfo, Integration[]>
```

**Hooks:**

| Hook | Returns |
|------|---------|
| `useIntegrationsRegistry()` | `Integration[]` |
| `useIntegrationsGrouped()` | `Map<IntegrationCategoryInfo, Integration[]>` |

---

### notificationPreferencesRegistry

**Import:** `@/config/notification-preferences.registry`

**Item type:** `NotificationPreference`

```typescript
interface NotificationPreference extends RegistryItem {
  id: string;
  label: string;
  description: string;
  defaultValue?: boolean;
  order?: number;
  category?: string;
}
```

**Additional methods:**

```typescript
notificationPreferencesRegistry.getGrouped(): Map<string, NotificationPreference[]>
notificationPreferencesRegistry.getDefaults(): Record<string, boolean>
```

**Hook:** `useNotificationPreferencesRegistry()` → `NotificationPreference[]`

---

### languageOptionsRegistry

**Import:** `@/config/language-options.registry`

**Item type:** `LanguageOption`

```typescript
interface LanguageOption extends RegistryItem {
  id: string;       // Language code (e.g., 'en-US')
  label: string;    // Display name (e.g., 'English (US)')
  order?: number;
  rtl?: boolean;    // Right-to-left language
}
```

**Additional methods:**

```typescript
languageOptionsRegistry.getAllForDropdown(): { value: string; label: string }[]
languageOptionsRegistry.isRtl(id: string): boolean
```

**Hooks:**

| Hook | Returns |
|------|---------|
| `useLanguageOptionsRegistry()` | `LanguageOption[]` |
| `useLanguageDropdownOptions()` | `{ value, label }[]` |

---

### personalInfoFieldsRegistry

**Import:** `@/config/personal-info-fields.registry`

**Item type:** `PersonalInfoField` (union type)

```typescript
type PersonalInfoFieldType = 'text' | 'textarea' | 'select' | 'custom';

// All types share these base fields:
interface BaseFieldConfig extends RegistryItem {
  id: string;
  label: string;
  description?: string;
  required?: boolean;
  order?: number;
  category?: string;
  storage?: 'profile' | 'preferences';
}

// Union of all field types:
type PersonalInfoField =
  | TextFieldConfig       // { type: 'text', placeholder?, maxLength? }
  | TextareaFieldConfig   // { type: 'textarea', placeholder?, maxLength?, rows? }
  | SelectFieldConfig     // { type: 'select', options: SelectOption[], placeholder? }
  | CustomFieldConfig     // { type: 'custom', component: ComponentType }
```

**Additional methods:**

```typescript
personalInfoFieldsRegistry.registerCategory(category: FieldCategory): void
personalInfoFieldsRegistry.getByCategory(categoryId: string): PersonalInfoField[]
personalInfoFieldsRegistry.getUncategorized(): PersonalInfoField[]
personalInfoFieldsRegistry.getGrouped(): Array<[FieldCategory | undefined, PersonalInfoField[]]>
personalInfoFieldsRegistry.getCategories(): FieldCategory[]
```

**Hooks:**

| Hook | Returns |
|------|---------|
| `usePersonalInfoFieldsRegistry()` | `PersonalInfoField[]` |
| `usePersonalInfoFieldsGrouped()` | `[FieldCategory \| undefined, PersonalInfoField[]][]` |
| `usePersonalInfoFieldCategories()` | `FieldCategory[]` |

---

## Frontend Pipeline Registries

Pipeline registries (`filterRegistry`, `actionRegistry`) do **not** extend `BaseRegistry`. They use a hook-based pattern instead, similar to WordPress filters and actions.

---

### filterRegistry

**Import:** `@/config/filter.registry`

Transforms values through a pipeline of registered callbacks.

```typescript
// Register a filter
filterRegistry.register<T, C>(
  hook: string,           // Hook name (e.g., 'user:displayName')
  id: string,             // Unique filter ID
  callback: (value: T, context: C) => T,
  order?: number          // Default: 10
): void

// Remove a filter
filterRegistry.unregister(hook: string, id: string): void

// Apply all filters to a value
filterRegistry.apply<T, C>(hook: string, value: T, context?: C): T

// Utility methods
filterRegistry.hasFilters(hook: string): boolean
filterRegistry.getHooks(): string[]
filterRegistry.getFilterCount(hook: string): number
filterRegistry.getFilterIds(hook: string): string[]
```

**Example:**

```typescript
// Register a filter that appends " (Admin)" to admin display names
filterRegistry.register('user:displayName', 'admin-badge',
  (name: string, context: { role: string }) => {
    return context.role === 'admin' ? `${name} (Admin)` : name;
  },
  20
);

// Apply all registered filters
const displayName = filterRegistry.apply('user:displayName', user.name, { role: user.role });
```

---

### actionRegistry

**Import:** `@/config/action.registry`

Executes side effects at defined hook points.

```typescript
// Register sync action
actionRegistry.addAction<C>(
  hook: string,
  id: string,
  callback: (context: C) => void,
  order?: number
): void

// Register async action
actionRegistry.addActionAsync<C>(
  hook: string,
  id: string,
  callback: (context: C) => Promise<void>,
  order?: number
): void

// Remove an action
actionRegistry.removeAction(hook: string, id: string): boolean
actionRegistry.removeAllActions(hook: string): number

// Execute actions
actionRegistry.doAction<C>(hook: string, context?: C): void           // Sync only
actionRegistry.doActionAsync<C>(hook: string, context?: C): Promise<void>  // Sequential
actionRegistry.doActionAll<C>(hook: string, context?: C): Promise<void>    // Sequential (sync + async)
actionRegistry.doActionParallel<C>(hook: string, context?: C): Promise<void> // Parallel

// Utility
actionRegistry.hasActions(hook: string): boolean
actionRegistry.countActions(hook: string): number
actionRegistry.getHooks(): string[]
actionRegistry.getActionIds(hook: string): string[]
actionRegistry.clear(): void
```

---

## Backend Registries

### routeRegistry

**Import:** `@/config/route.registry` (backend)

See [Auth Feature — Route Registry Details](/starter-template/auth-feature/#route-registry-details) for full documentation.

```typescript
type ApiVersion = 'v1' | 'v2';

interface RouteConfig {
  path: string;
  router: Router;
  versions?: ApiVersion[];        // Default: ['v1']
  middleware?: RequestHandler[];
  requiresAuth?: boolean;         // Default: true
  feature: string;
  description?: string;
  deprecated?: boolean;
  deprecationMessage?: string;
}

interface PublicRouteConfig {
  path: string;
  method: 'get' | 'post' | 'put' | 'patch' | 'delete';
  handler: RequestHandler;
  description?: string;
}

routeRegistry.register(config: RouteConfig): void
routeRegistry.registerPublic(config: PublicRouteConfig): void
routeRegistry.mountAll(app: Express, authMiddleware: RequestHandler): void
routeRegistry.getAll(): RegisteredRoute[]
routeRegistry.getPublicRoutes(): PublicRouteConfig[]
routeRegistry.getByFeature(feature: string): RegisteredRoute[]
routeRegistry.getByVersion(version: ApiVersion): RegisteredRoute[]
routeRegistry.isMounted(): boolean
routeRegistry.generateDocs(): object
routeRegistry.clear(): void
```

---

### serviceRegistry

**Import:** `@/config/service.registry` (backend)

```typescript
interface ServiceMetadata {
  feature: string;
  description?: string;
  version?: string;
}

// Type-safe interface (extend via module augmentation)
interface ServiceTypes {}

serviceRegistry.register<K extends keyof ServiceTypes>(
  name: K, instance: ServiceTypes[K], metadata: ServiceMetadata
): void
serviceRegistry.registerDynamic<T>(name: string, instance: T, metadata: ServiceMetadata): void

serviceRegistry.get<K extends keyof ServiceTypes>(name: K): ServiceTypes[K]
serviceRegistry.getOptional<K extends keyof ServiceTypes>(name: K): ServiceTypes[K] | undefined
serviceRegistry.getDynamic<T>(name: string): T
serviceRegistry.has(name: string): boolean

serviceRegistry.getNames(): string[]
serviceRegistry.getMetadata(): Record<string, ServiceMetadata>
serviceRegistry.getByFeature(feature: string): string[]
serviceRegistry.unregister(name: string): boolean
serviceRegistry.clear(): void
serviceRegistry.count(): number
```

---

### filterRegistry (Backend)

**Import:** `@/config/filter.registry` (backend)

Same as frontend, plus async support:

```typescript
// Async filter registration
filterRegistry.registerAsync<T, C>(
  hook: string,
  id: string,
  callback: (value: T, context: C) => T | Promise<T>,
  order?: number
): void
filterRegistry.unregisterAsync(hook: string, id: string): void

// Async application
filterRegistry.applyAsync<T, C>(hook: string, value: T, context?: C): Promise<T>  // Async only
filterRegistry.applyAll<T, C>(hook: string, value: T, context?: C): Promise<T>    // Sync then async

// Inspection
filterRegistry.hasSyncFilters(hook: string): boolean
filterRegistry.hasAsyncFilters(hook: string): boolean
filterRegistry.getFilterCount(hook: string): { sync: number; async: number }
filterRegistry.getFilterIds(hook: string): { sync: string[]; async: string[] }
```

---

### actionRegistry (Backend)

**Import:** `@/config/action.registry` (backend)

Same as frontend, plus:

```typescript
// Execute with results (returns success/failure per action)
actionRegistry.doActionWithResults<C>(
  hook: string,
  context?: C
): Promise<{ id: string; success: boolean; error?: Error }[]>

// Inspection
actionRegistry.getActionInfo(hook: string): { id: string; order: number; async: boolean }[]
```
