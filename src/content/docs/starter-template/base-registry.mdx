---
title: Base Registry Pattern
description: Understanding the BaseRegistry class and how to create custom registries
---

import { Tabs, TabItem, Aside } from '@astrojs/starlight/components';

The `BaseRegistry<T>` class is the foundation for all collection registries in the system. It provides standardised registration, ordering, duplicate handling, and React integration.

---

## Why BaseRegistry?

Instead of each registry implementing its own storage, sorting, and React subscription logic, they all extend `BaseRegistry<T>`. This ensures:

- **Consistent API** across all registries
- **React integration** via `useSyncExternalStore`
- **Automatic sorting** by `order` field
- **Duplicate detection** with configurable behaviour
- **Reduced code duplication**

---

## Core Concepts

### Items and IDs

Every registry item must have a unique `id` and can optionally specify an `order`:

```typescript
interface RegistryItem {
  id: string;      // Unique identifier
  order?: number;  // Sort order (lower = earlier)
}
```

### Registration Flow

When you call `register()`:

1. Check if item with same `id` exists
2. If exists and `allowReplace` is false, skip (warn unless `silent`)
3. Apply default `order` if not specified
4. Store item in internal Map
5. Update sorted snapshot
6. Notify React subscribers

```
register(item) → Check Duplicate → Apply Defaults → Store → Sort → Notify
```

### Sorting

Items are automatically sorted by their `order` field. Lower numbers come first:

```typescript
// These items will appear in this order: dashboard, projects, billing
registry.register({ id: 'billing', order: 50 });
registry.register({ id: 'dashboard', order: 10 });
registry.register({ id: 'projects', order: 30 });
```

---

## BaseRegistry API

### Constructor

```typescript
abstract class BaseRegistry<T extends RegistryItem> {
  constructor(registryName: string, defaultOrder: number = 10)
}
```

| Parameter | Description |
|-----------|-------------|
| `registryName` | Used in console warnings for debugging |
| `defaultOrder` | Default order value when items don't specify one |

### Registration Methods

```typescript
// Register a single item
register(item: T, options?: RegistrationOptions): boolean

// Register multiple items at once (single notification)
registerMany(items: T[], options?: RegistrationOptions): number

// Remove an item by ID
unregister(id: string): boolean

// Remove multiple items
unregisterMany(ids: string[]): number

// Remove all items
clear(): void
```

### Registration Options

```typescript
interface RegistrationOptions {
  allowReplace?: boolean;  // Allow replacing existing item (default: false)
  silent?: boolean;        // Suppress duplicate warning (default: false)
}
```

### Retrieval Methods

```typescript
get(id: string): T | undefined      // Get item by ID
getAll(): T[]                        // Get all items (sorted)
has(id: string): boolean             // Check if item exists
count(): number                      // Get item count
getIds(): string[]                   // Get all IDs
```

### React Integration

```typescript
// Subscribe to changes (for useSyncExternalStore)
subscribe(listener: () => void): () => void

// Get current snapshot
getSnapshot(): T[]
```

---

## Order Convention

All registries follow this ordering convention:

| Range | Purpose | Use For |
|-------|---------|---------|
| 1-9 | Core/critical | System items that must run first |
| 10 | Default | Standard feature items |
| 11-49 | Early features | Items that should appear early |
| 50-99 | Standard features | Most feature items |
| 100+ | Late/third-party | Items that should appear last |

<Aside type="tip">
Lower numbers appear first in lists and execute first in pipelines.
</Aside>

---

## Creating a Custom Registry

### Step 1: Define Your Item Type

```typescript
// my-widget.registry.ts
import { BaseRegistry, createRegistryHook, type RegistryItem } from './base.registry';
import type { ComponentType } from 'react';

// Extend RegistryItem with your fields
interface MyWidget extends RegistryItem {
  id: string;
  title: string;
  component: ComponentType;
  category?: string;
  order?: number;
}
```

### Step 2: Create the Registry Class

```typescript
class MyWidgetRegistry extends BaseRegistry<MyWidget> {
  constructor() {
    super('MyWidgetRegistry', 10); // name, defaultOrder
  }

  // Add custom methods as needed
  getByCategory(category: string): MyWidget[] {
    return this.getAll().filter(w => w.category === category);
  }

  getCategories(): string[] {
    return [...new Set(this.getAll().map(w => w.category).filter(Boolean))];
  }
}
```

### Step 3: Create Singleton and Hook

```typescript
// Singleton instance
export const myWidgetRegistry = new MyWidgetRegistry();

// React hook using the utility
export const useMyWidgets = createRegistryHook(myWidgetRegistry);

// Optional: convenience hooks
export function useMyWidgetsByCategory(category: string) {
  useMyWidgets(); // Subscribe to changes
  return myWidgetRegistry.getByCategory(category);
}
```

### Step 4: Export Types

```typescript
export type { MyWidget };
```

---

## React Hook Utility

The `createRegistryHook` utility creates a hook that automatically subscribes to registry changes:

```typescript
import { useSyncExternalStore } from 'react';

export function createRegistryHook<T extends RegistryItem>(
  registry: BaseRegistry<T>
): () => T[] {
  return () =>
    useSyncExternalStore(
      (listener) => registry.subscribe(listener),
      () => registry.getSnapshot()
    );
}
```

Usage in components:

```typescript
const useMyRegistry = createRegistryHook(myRegistry);

function MyComponent() {
  const items = useMyRegistry(); // Re-renders when registry changes
  return (
    <div>
      {items.map(item => <Item key={item.id} item={item} />)}
    </div>
  );
}
```

---

## Frontend vs Backend

<Tabs>
  <TabItem label="Frontend">
Located at `frontend/src/config/base.registry.ts`

**Features:**
- React subscription via `useSyncExternalStore`
- `createRegistryHook()` utility for easy hook creation
- Cached snapshot for performance
- Listener notification on changes

```typescript
// Frontend registry with React integration
class NavigationRegistry extends BaseRegistry<NavItem> {
  // Can use React hooks
}

export const useNavigation = createRegistryHook(navigationRegistry);
```
  </TabItem>
  <TabItem label="Backend">
Located at `backend/src/config/base.registry.ts`

**Features:**
- No React dependencies
- Lazy-cached sorted array
- Same registration API
- Optimised for server-side use

```typescript
// Backend registry - no React
class RouteRegistry extends BaseRegistry<RouteConfig> {
  // Server-side only methods
  mountAll(app: Express): void { ... }
}
```
  </TabItem>
</Tabs>

---

## Best Practices

### 1. Use Unique, Descriptive IDs

```typescript
// ✅ Good - unique, descriptive ID
myRegistry.register({
  id: 'billing-overview-widget',
  // ...
});

// ❌ Bad - generic ID risks collisions
myRegistry.register({
  id: 'widget-1',
  // ...
});
```

### 2. Use Side-Effect Imports for Registration

```typescript
// features/billing/index.ts
import './widget.registration';  // Triggers registration on import

// features/billing/widget.registration.ts
import { myWidgetRegistry } from '@/config/my-widget.registry';

myWidgetRegistry.register({
  id: 'billing-widget',
  title: 'Billing Overview',
  // ...
});
```

### 3. Batch Updates for Performance

```typescript
// ✅ Good - single notification
myRegistry.registerMany([item1, item2, item3]);

// ❌ Less efficient - three notifications
myRegistry.register(item1);
myRegistry.register(item2);
myRegistry.register(item3);
```

### 4. Override Methods When Needed

```typescript
class SpecialRegistry extends BaseRegistry<SpecialItem> {
  // Override register to add defaults
  override register(item: SpecialItem, options = {}): boolean {
    const withDefaults = {
      isActive: true,
      ...item,
    };
    return super.register(withDefaults, options);
  }

  // Override updateSnapshot for custom sorting
  protected override updateSnapshot(): void {
    this.snapshot = Array.from(this.items.values())
      .sort((a, b) => {
        // Custom sort: by category first, then by order
        if (a.category !== b.category) {
          return a.category.localeCompare(b.category);
        }
        return (a.order ?? 10) - (b.order ?? 10);
      });
  }
}
```

---

## When Not to Use BaseRegistry

Some registries have specialised requirements that don't fit the collection pattern:

| Registry | Pattern | Why Different |
|----------|---------|---------------|
| `FilterRegistry` | Pipeline | Transforms data through chain of functions |
| `ActionRegistry` | Event | Executes side effects, doesn't store items |
| `RouteRegistry` | Express-specific | Has mounting logic, versioning |
| `ServiceRegistry` | Type augmentation | Needs TypeScript type safety |

These registries implement their own patterns optimised for their use cases.

---

## Complete Example

Here's a complete example of creating a notifications registry:

```typescript
// frontend/src/config/notification.registry.ts
import { BaseRegistry, createRegistryHook, type RegistryItem } from './base.registry';
import type { ComponentType } from 'react';
import type { LucideIcon } from 'lucide-react';

// ========================================================================
// TYPES
// ========================================================================

interface NotificationConfig extends RegistryItem {
  id: string;
  title: string;
  message: string;
  icon?: LucideIcon;
  type: 'info' | 'success' | 'warning' | 'error';
  dismissable?: boolean;
  order?: number;
}

// ========================================================================
// REGISTRY CLASS
// ========================================================================

class NotificationRegistry extends BaseRegistry<NotificationConfig> {
  constructor() {
    super('NotificationRegistry', 10);
  }

  getByType(type: NotificationConfig['type']): NotificationConfig[] {
    return this.getAll().filter(n => n.type === type);
  }

  dismiss(id: string): boolean {
    const item = this.get(id);
    if (item?.dismissable !== false) {
      return this.unregister(id);
    }
    return false;
  }

  dismissAll(): void {
    const dismissable = this.getAll().filter(n => n.dismissable !== false);
    this.unregisterMany(dismissable.map(n => n.id));
  }
}

// ========================================================================
// SINGLETON AND HOOKS
// ========================================================================

export const notificationRegistry = new NotificationRegistry();
export const useNotifications = createRegistryHook(notificationRegistry);

export function useErrorNotifications() {
  useNotifications(); // Subscribe
  return notificationRegistry.getByType('error');
}

// ========================================================================
// TYPE EXPORTS
// ========================================================================

export type { NotificationConfig };
```

Usage:

```typescript
// Show a notification
notificationRegistry.register({
  id: 'save-success',
  title: 'Saved',
  message: 'Your changes have been saved.',
  type: 'success',
  dismissable: true,
});

// In a component
function NotificationBanner() {
  const notifications = useNotifications();

  return (
    <div>
      {notifications.map(n => (
        <Alert key={n.id} type={n.type}>
          {n.message}
          {n.dismissable && (
            <button onClick={() => notificationRegistry.dismiss(n.id)}>
              Dismiss
            </button>
          )}
        </Alert>
      ))}
    </div>
  );
}
```
