---
title: Authentication
description: How authentication works with Neon Auth — frontend setup, backend verification, and how modules integrate with the auth system
sidebar:
  order: 7
---

import { Aside, Steps, Tabs, TabItem } from '@astrojs/starlight/components';

The starter template uses [Neon Auth](https://neon.tech/docs/guides/neon-auth) for authentication, providing secure JWT-based auth with multiple sign-in methods.

<Aside type="caution">
  **Beta Notice:** Neon Auth is currently in beta. The API may change, and some features may be experimental. Monitor [Neon's documentation](https://neon.tech/docs/guides/neon-auth) for updates.
</Aside>

---

## How It Works

The authentication system has two halves — the **frontend** handles sign-in UI and session management, while the **backend** verifies JWT tokens and enforces access control.

```
┌─────────────────────────────────────────────────────────────────┐
│  FRONTEND                                                       │
│                                                                 │
│  1. User signs in via Neon Auth UI (email OTP / credentials /   │
│     Google OAuth)                                               │
│  2. Neon Auth issues a JWT token and stores it in the session   │
│  3. api.ts interceptor attaches token to every API request:     │
│     Authorization: Bearer <token>                               │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│  BACKEND                                                        │
│                                                                 │
│  4. requireAuth middleware extracts the Bearer token             │
│  5. Token is verified against Neon Auth's JWKS endpoint         │
│  6. req.user = { id, email } is attached to the request         │
│  7. Route handler runs with authenticated user context          │
│  8. On first API call, user profile is auto-created in DB       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Supported Auth Methods

The template enables these methods by default:

| Method | Description |
|--------|-------------|
| **Email OTP** | Magic link sent to email |
| **Credentials** | Email + password with forgot password |
| **Google OAuth** | Sign in with Google account |

<Aside type="tip">
  Configure additional OAuth providers (GitHub, Discord, etc.) in your Neon console.
</Aside>

---

## File Structure

```
frontend/src/features/auth/
├── index.ts                    # Public exports (barrel file)
├── routes.config.tsx           # Auth routes (/auth/*)
├── lib/
│   ├── client.ts               # Neon Auth client instance
│   └── getAuthToken.ts         # Token retrieval for API calls
├── hooks/
│   └── useSession.ts           # Session hook + TypeScript types
├── components/
│   ├── AuthProtectedRoute.tsx  # Route guard component
│   └── AccountSettings.tsx     # Account settings UI
└── pages/
    └── AuthPage.tsx            # Sign in/up/forgot password page

backend/src/middleware/
└── auth.middleware.ts          # JWT verification + role checks
```

---

## Frontend Setup

### Neon Auth Client

The auth client is initialised in `lib/client.ts`:

```typescript
// frontend/src/features/auth/lib/client.ts
import { createAuthClient } from '@neondatabase/neon-js/auth';
import { BetterAuthReactAdapter } from '@neondatabase/neon-js/auth/react';

export const authClient = createAuthClient(
  import.meta.env.VITE_NEON_AUTH_URL,
  {
    adapter: BetterAuthReactAdapter(),
  }
);

// Alias for cleaner imports
export const auth = authClient;
```

### App Provider Setup

In `main.tsx`, the app is wrapped with `NeonAuthUIProvider`:

```tsx
// frontend/src/main.tsx
import { NeonAuthUIProvider } from '@neondatabase/neon-js/auth/react';
import { authClient } from '@/features/auth';

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <NeonAuthUIProvider
      authClient={authClient}
      emailOTP
      credentials={{ forgotPassword: true }}
      social={{ providers: ['google'] }}
    >
      <App />
    </NeonAuthUIProvider>
  </StrictMode>
);
```

---

## Using Authentication

### Protecting Routes

All protected routes are wrapped with `AuthProtectedRoute` in `routes.tsx`:

```tsx
// frontend/src/routes.tsx
import { AuthProtectedRoute, authRoutes } from '@/features/auth';
import { DashboardPage, dashboardRoutes } from '@/features/dashboard';

export const router = createBrowserRouter([
  // Public routes (no auth required)
  ...authRoutes,

  // Protected routes (auth required)
  {
    element: (
      <AuthProtectedRoute>
        <DashboardPage />
      </AuthProtectedRoute>
    ),
    children: [
      ...dashboardRoutes,
      ...userRoutes,
      ...adminRoutes,
      // ...yourModuleRoutes,  ← add your module routes here
    ],
  },
]);
```

The `AuthProtectedRoute` component:
1. Shows a loading spinner while checking the session
2. Redirects to `/auth/sign-in` if the user is not authenticated
3. Renders children if authenticated

```tsx
// frontend/src/features/auth/components/AuthProtectedRoute.tsx
export function AuthProtectedRoute({ children }: { children: React.ReactNode }) {
  const { data, isPending } = useSession();

  if (isPending) {
    return <div className="flex min-h-screen items-center justify-center">Loading...</div>;
  }

  if (!data?.user) {
    return <Navigate to="/auth/sign-in" replace />;
  }

  return <>{children}</>;
}
```

### Getting Session Data

Use the `useSession` hook in any React component:

```tsx
import { useSession } from '@/features/auth';

function MyComponent() {
  const { data, isPending, error } = useSession();

  if (isPending) return <Spinner />;
  if (error) return <ErrorMessage />;

  const user = data?.user;
  const isLoggedIn = !!data?.user;

  return <div>Hello, {user?.name || user?.email}</div>;
}
```

### Session Data Structure

```typescript
// Returned by useSession().data
type SessionData = {
  user: SessionUser;
  session: Session;
} | null;

type SessionUser = {
  id: string;              // Neon Auth user ID (used as profile ID)
  name: string;            // Display name
  email: string;           // Email address
  emailVerified: boolean;  // Whether email has been verified
  image?: string | null;   // Profile picture URL (from OAuth)
  createdAt: Date;         // Account creation date
  updatedAt: Date;         // Last update date
};

type Session = {
  id: string;        // Session ID
  token: string;     // JWT token for API authentication
  userId: string;    // User ID this session belongs to
  expiresAt: Date;   // Session expiration time
};
```

### Getting Token for API Calls

The `api.ts` client automatically handles token injection for all requests. You don't need to manually pass tokens.

For non-React code (like standalone utilities), use `getAuthToken`:

```typescript
import { getAuthToken } from '@/features/auth';

async function myUtilityFunction() {
  const token = await getAuthToken();
  if (token) {
    // Use the token directly
    headers.Authorization = `Bearer ${token}`;
  }
}
```

---

## The API Client

The `api.ts` client is the bridge between frontend and backend. Understanding it is essential for modules.

```typescript
// frontend/src/lib/api.ts
import axios from 'axios';
import { appConfig } from '@/config/app.config';

// Pre-configured Axios instance
export const api = axios.create({
  baseURL: appConfig.apiUrl,
  headers: { 'Content-Type': 'application/json' },
});

// Request interceptor: automatically injects JWT token
api.interceptors.request.use(async (config) => {
  const { getAuthToken } = await import('@/features/auth');
  const token = await getAuthToken();

  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }

  return config;
});

// Response interceptor: logs 401 errors
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      console.warn('API request unauthorized:', error.config?.url);
    }
    return Promise.reject(error);
  }
);
```

### How Modules Use the API Client

Every module should import `api` from `@/lib/api` for all API calls. The token injection happens automatically — you never need to handle auth tokens manually.

```typescript
// frontend/src/features/billing/services/billing.service.ts
import { api } from '@/lib/api';

export const billingService = {
  async getSubscription() {
    // Token is automatically included in the Authorization header
    const response = await api.get('/api/v1/billing/subscription');
    return response.data;
  },

  async updatePlan(planId: string) {
    const response = await api.patch('/api/v1/billing/plan', { planId });
    return response.data;
  },
};
```

<Aside type="caution">
  **Never create your own Axios instance** for API calls. Always use the shared `api` client from `@/lib/api`. This ensures tokens are attached and errors are handled consistently.
</Aside>

---

## Backend Middleware

### JWT Verification (requireAuth)

The `requireAuth` middleware verifies JWT tokens using JWKS (JSON Web Key Set) from the Neon Auth endpoint:

```typescript
// backend/src/middleware/auth.middleware.ts
import { createRemoteJWKSet, jwtVerify } from 'jose';
import { env } from '../config/env.js';

// JWKS client — automatically caches and refreshes public keys
const baseUrl = env.NEON_AUTH_URL.endsWith('/')
  ? env.NEON_AUTH_URL.slice(0, -1)
  : env.NEON_AUTH_URL;
const jwksUrl = new URL(`${baseUrl}/.well-known/jwks.json`);
const JWKS = createRemoteJWKSet(jwksUrl);

export async function requireAuth(req: Request, res: Response, next: NextFunction) {
  try {
    const authHeader = req.headers.authorization;

    if (!authHeader?.startsWith('Bearer ')) {
      res.status(401).json({ error: 'Missing authorization header' });
      return;
    }

    const token = authHeader.slice(7);
    const { payload } = await jwtVerify(token, JWKS);

    // Attach user data to the request object
    req.user = {
      id: payload.sub as string,     // 'sub' claim = user ID
      email: payload.email as string, // 'email' claim = user email
    };

    next();
  } catch (err) {
    res.status(401).json({ error: 'Invalid token' });
  }
}
```

After `requireAuth` runs, every route handler has access to `req.user`:

```typescript
router.get('/', async (req, res) => {
  const userId = req.user!.id;    // Neon Auth user ID
  const email = req.user!.email;  // User's email
  // ...
});
```

### Extended Request Type

The middleware extends the Express `Request` type globally:

```typescript
// Available in all route handlers after requireAuth
declare global {
  namespace Express {
    interface Request {
      user?: {
        id: string;        // Neon Auth user ID (JWT 'sub' claim)
        email: string;     // User's email (JWT 'email' claim)
        role?: UserRole;   // Populated by requireAdmin/requireRole/attachRole
      };
    }
  }
}

type UserRole = 'user' | 'admin' | 'managed';
```

### Role-Based Middleware

The template provides three role-based middleware functions, all of which must be used **after** `requireAuth`:

#### requireAdmin

Requires the user to have the `admin` role. Queries the database to check the user's role, then returns 403 if not admin.

There are **two ways** to apply `requireAdmin`:

**Option A: At the route registry level** — all routes in the router require admin:

```typescript
import { requireAdmin } from '../../middleware/auth.middleware.js';

routeRegistry.register({
  path: '/billing/admin',
  router: billingAdminRoutes,
  feature: 'billing',
  requiresAuth: true,
  middleware: [requireAdmin],  // Applied to ALL routes in this router
  description: 'Billing admin operations',
});
```

**Option B: Per-route inside the router** — some routes require admin, others don't:

```typescript
import { requireAdmin } from '../../middleware/auth.middleware.js';

const router = Router();

// Public to all authenticated users (no requireAdmin)
router.get('/settings', async (req, res, next) => {
  const settings = await adminService.getAppSettings();
  res.json(settings);
});

// Admin only — requireAdmin applied to this specific route
router.patch('/settings', requireAdmin, validate(UpdateAppSettingsSchema),
  async (req, res, next) => {
    const settings = await adminService.updateAppSettings(req.body);
    res.json(settings);
  }
);

// Admin only
router.get('/users', requireAdmin, async (req, res, next) => {
  const users = await adminService.getAllUsers();
  res.json(users);
});
```

<Aside type="tip">
  The starter template's own admin feature uses **Option B** (per-route). `GET /admin/settings` is accessible to all authenticated users so the sidebar can fetch branding, but all other admin routes have `requireAdmin` applied individually.
</Aside>

**When to use which:**
- **Option A** — When the entire router is admin-only (e.g., a billing admin panel)
- **Option B** — When some routes are public to authenticated users but others need admin access (e.g., the admin feature itself)

#### requireRole

Factory function that checks for specific role(s). Admin always has access by default:

```typescript
import { requireRole } from '../../middleware/auth.middleware.js';

// Require a specific role (admin still has access)
router.use('/editor', requireRole('editor'));

// Require one of multiple roles
router.use('/special', requireRole(['editor', 'moderator']));

// Disable admin bypass — strictly 'editor' role only
router.use('/editor-only', requireRole('editor', { adminBypass: false }));
```

#### attachRole

Attaches the user's role to `req.user` without enforcing a specific role. Useful when you need to check the role in your handler logic:

```typescript
router.get('/content', attachRole, async (req, res) => {
  if (req.user?.role === 'admin') {
    // Return admin-specific data
  } else {
    // Return standard data
  }
});
```

### User Roles

| Role | Description |
|------|-------------|
| `user` | Default role. Standard access to all user-facing features. |
| `admin` | Full administrative access. Bypasses most role restrictions. |
| `managed` | Permissions controlled by an external module. Without a permissions module, behaves like `user`. |

<Aside type="tip">
**About the `managed` role:** The template includes infrastructure for a future permissions module. When you need fine-grained control beyond "user" and "admin" (e.g., "can edit posts but not delete"), set the user's role to `managed` and install a permissions module to handle the granular access control.
</Aside>

---

## How Modules Add Authenticated API Routes

This section walks through the complete pattern for a module to add its own backend API that uses the auth system.

### Step 1: Define Routes

Create an Express router with your endpoints. After `requireAuth` runs (applied automatically by the route registry), `req.user` is available in every handler:

```typescript
// backend/src/features/billing/billing.routes.ts
import { Router, Request, Response, NextFunction } from 'express';
import { billingService } from './billing.service.js';

const router = Router();

// GET /api/v1/billing — get user's subscription
router.get('/', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const subscription = await billingService.getSubscription(req.user!.id);
    res.json(subscription);
  } catch (error) {
    next(error);
  }
});

// POST /api/v1/billing/checkout — create checkout session
router.post('/checkout', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const session = await billingService.createCheckout(
      req.user!.id,
      req.user!.email,
      req.body.planId
    );
    res.json(session);
  } catch (error) {
    next(error);
  }
});

export const billingRoutes = router;
```

### Step 2: Register Routes

Register your routes with the route registry. Setting `requiresAuth: true` (the default) automatically applies the `requireAuth` middleware:

```typescript
// backend/src/features/billing/route.registration.ts
import { routeRegistry } from '../../config/route.registry.js';
import { billingRoutes } from './billing.routes.js';

routeRegistry.register({
  path: '/billing',
  router: billingRoutes,
  feature: 'billing',
  versions: ['v1'],
  requiresAuth: true,    // default — applies requireAuth automatically
  description: 'Billing and subscription management',
});
```

This mounts the routes at `/api/v1/billing/*` with auth middleware applied.

### Step 3: Add Admin-Only Routes

If your module has admin endpoints, you have two approaches:

**Approach A: Separate registration with `middleware` array** — use when the entire router is admin-only:

```typescript
// backend/src/features/billing/route.registration.ts
import { routeRegistry } from '../../config/route.registry.js';
import { requireAdmin } from '../../middleware/auth.middleware.js';
import { billingRoutes } from './billing.routes.js';
import { billingAdminRoutes } from './billing-admin.routes.js';

// User-facing routes
routeRegistry.register({
  path: '/billing',
  router: billingRoutes,
  feature: 'billing',
  requiresAuth: true,
  description: 'Billing for users',
});

// Admin-only routes — requireAdmin applied to ALL routes in this router
routeRegistry.register({
  path: '/billing/admin',
  router: billingAdminRoutes,
  feature: 'billing',
  requiresAuth: true,
  middleware: [requireAdmin],
  description: 'Billing admin operations',
});
```

**Approach B: Per-route middleware inside the router** — use when some routes need admin but others don't:

```typescript
// backend/src/features/billing/billing.routes.ts
import { Router } from 'express';
import { requireAdmin } from '../../middleware/auth.middleware.js';

const router = Router();

// Accessible to all authenticated users
router.get('/', async (req, res, next) => {
  const subscription = await billingService.getSubscription(req.user!.id);
  res.json(subscription);
});

// Admin only — applied per-route
router.get('/all-subscriptions', requireAdmin, async (req, res, next) => {
  const all = await billingService.getAllSubscriptions();
  res.json(all);
});

router.delete('/:id', requireAdmin, async (req, res, next) => {
  await billingService.cancelSubscription(req.params.id);
  res.json({ success: true });
});

export const billingRoutes = router;
```

<Aside type="tip">
  The starter template's own admin feature uses **Approach B**. `GET /admin/settings` is accessible to all authenticated users (so the sidebar can fetch branding), while all other admin routes apply `requireAdmin` individually.
</Aside>

### Step 4: Import in Feature Index

The feature's `index.ts` must import the registration files as side effects:

```typescript
// backend/src/features/billing/index.ts

// Side-effect imports — trigger route and service registration
import './route.registration.js';
import './service.registration.js';

// Public exports
export { billingRoutes } from './billing.routes.js';
export { billingService } from './billing.service.js';
```

### Step 5: Import in app.ts

Add the feature import to `app.ts`:

```typescript
// backend/src/app.ts

// Feature registrations (side-effect imports)
import './features/user/index.js';
import './features/admin/index.js';
import './features/billing/index.js';  // ← add your module
```

### Step 6: Create Frontend Service

Create a frontend API service using the shared `api` client:

```typescript
// frontend/src/features/billing/services/billing.service.ts
import { api } from '@/lib/api';

export const billingService = {
  async getSubscription() {
    const response = await api.get('/api/v1/billing');
    return response.data;
  },

  async createCheckout(planId: string) {
    const response = await api.post('/api/v1/billing/checkout', { planId });
    return response.data;
  },
};
```

<Aside type="note">
  The `api` client handles token injection automatically. You never need to pass tokens manually.
</Aside>

---

## Route Registry Details

The route registry manages how routes are mounted in Express:

### RouteConfig Interface

```typescript
interface RouteConfig {
  /** Base path without version prefix (e.g., '/billing') */
  path: string;
  /** Express router with route handlers */
  router: Router;
  /** API version(s). Default: ['v1'] */
  versions?: ApiVersion[];
  /** Additional middleware (applied after auth) */
  middleware?: RequestHandler[];
  /** Whether route requires auth. Default: true */
  requiresAuth?: boolean;
  /** Feature/module name for documentation */
  feature: string;
  /** Description for /api/docs endpoint */
  description?: string;
  /** Mark as deprecated (adds Deprecation header) */
  deprecated?: boolean;
  /** Deprecation notice message */
  deprecationMessage?: string;
}
```

### How Mounting Works

When `routeRegistry.mountAll(app, requireAuth)` is called in `app.ts`:

1. **Public routes** are mounted first (no auth)
2. **Feature routes** are mounted with a middleware stack:
   - Deprecation warning header (if `deprecated: true`)
   - `requireAuth` middleware (if `requiresAuth: true`, the default)
   - Route-specific middleware (from `middleware` array)
   - The route's Express router

### API Versioning

Routes support versioning via the `versions` field:

```typescript
routeRegistry.register({
  path: '/billing',
  router: billingRoutes,
  feature: 'billing',
  versions: ['v1'],  // Mounts at /api/v1/billing
});

// When you need breaking changes, add a v2:
routeRegistry.register({
  path: '/billing',
  router: billingRoutesV2,
  feature: 'billing',
  versions: ['v2'],
});
```

### Public Routes (No Auth)

For routes that don't require authentication (e.g., webhooks):

```typescript
routeRegistry.registerPublic({
  path: '/api/billing/webhook',
  method: 'post',
  handler: async (req, res) => {
    // Handle Stripe webhook — no auth required
  },
  description: 'Stripe webhook endpoint',
});
```

### Auto-Generated API Docs

All registered routes appear at `/api/docs`:

```bash
curl http://localhost:3100/api/docs
```

This returns a JSON document listing all public and feature routes with their paths, auth requirements, and descriptions.

---

## Request Validation

Use the `validate` middleware with Zod schemas to validate request bodies:

```typescript
// backend/src/features/billing/billing.types.ts
import { z } from 'zod';

export const CreateCheckoutSchema = z.object({
  planId: z.string().min(1),
  billingCycle: z.enum(['monthly', 'annual']).optional(),
}).strict();

export type CreateCheckoutInput = z.infer<typeof CreateCheckoutSchema>;
```

```typescript
// backend/src/features/billing/billing.routes.ts
import { validate } from '../../middleware/validate.middleware.js';
import { CreateCheckoutSchema } from './billing.types.js';

router.post('/checkout',
  validate(CreateCheckoutSchema),
  async (req, res, next) => {
    // req.body is validated and typed
    const { planId, billingCycle } = req.body;
    // ...
  }
);
```

If validation fails, a structured 400 response is returned:

```json
{
  "error": "Validation failed",
  "details": {
    "planId": ["Required"],
    "billingCycle": ["Invalid enum value"]
  }
}
```

---

## Error Handling

The template provides custom error classes that map to HTTP status codes:

```typescript
import {
  BadRequestError,      // 400
  UnauthorizedError,    // 401
  ForbiddenError,       // 403
  NotFoundError,        // 404
  ConflictError,        // 409
  TooManyRequestsError, // 429
  InternalError,        // 500
} from '../../lib/errors.js';

// Throw in services or route handlers:
throw new NotFoundError('Subscription not found');
throw new ForbiddenError('Only plan owners can cancel');
throw new TooManyRequestsError('Too many requests', 60); // 60s retry-after
```

The global error handler in `error.middleware.ts` catches these and returns the appropriate HTTP response. Stack traces are only included in development mode.

---

## Service Registry

The service registry enables cross-feature communication on the backend without tight coupling:

### Registering a Service

```typescript
// backend/src/features/billing/service.registration.ts
import { serviceRegistry } from '../../config/service.registry.js';
import { billingService } from './billing.service.js';

// Type augmentation for type-safe access
declare module '../../config/service.registry.js' {
  interface ServiceTypes {
    billing: typeof billingService;
  }
}

serviceRegistry.register('billing', billingService, {
  feature: 'billing',
  description: 'Billing and subscription management',
  version: '1.0.0',
});
```

### Accessing Services from Other Features

```typescript
// In another feature's service
import { serviceRegistry } from '../../config/service.registry.js';

async function notifyUser(userId: string) {
  // Type-safe access to the user service
  const userService = serviceRegistry.get('user');
  const profile = await userService.getOrCreateProfile(userId, '');

  // Optional access (doesn't throw if service not registered)
  const billing = serviceRegistry.getOptional('billing');
  if (billing) {
    const subscription = await billing.getSubscription(userId);
  }
}
```

---

## User Profile Auto-Creation

On the first API call after sign-in, the user profile is automatically created in the database:

```typescript
// backend/src/features/user/user.service.ts
async getOrCreateProfile(userId: string, email: string) {
  let user = await prisma.user.findUnique({ where: { id: userId } });

  if (!user) {
    const userCount = await prisma.user.count();

    user = await prisma.user.create({
      data: {
        id: userId,        // Uses Neon Auth user ID as primary key
        email,
        role: userCount === 0 ? 'admin' : 'user',  // First user = admin
        preferences: {},
      },
    });
  }

  return user;
}
```

<Aside type="note">
  The first user to sign up automatically becomes an admin. All subsequent users get the `user` role.
</Aside>

---

## Complete Module Auth Integration Example

Here's the full picture of how a module integrates with authentication, from frontend to backend:

### Frontend Component

```tsx
// frontend/src/features/billing/pages/BillingPage.tsx
import { useEffect, useState } from 'react';
import { useSession } from '@/features/auth';
import { billingService } from '../services/billing.service';

export function BillingPage() {
  const { data: session } = useSession();
  const [subscription, setSubscription] = useState(null);

  useEffect(() => {
    // api client handles auth token automatically
    billingService.getSubscription().then(setSubscription);
  }, []);

  return (
    <div>
      <h1>Billing</h1>
      <p>Signed in as: {session?.user.email}</p>
      {/* Subscription UI */}
    </div>
  );
}
```

### Frontend Service

```typescript
// frontend/src/features/billing/services/billing.service.ts
import { api } from '@/lib/api';  // Shared API client with auto-auth

export const billingService = {
  async getSubscription() {
    const response = await api.get('/api/v1/billing');
    return response.data;
  },
};
```

### Backend Route Handler

```typescript
// backend/src/features/billing/billing.routes.ts
import { Router, Request, Response, NextFunction } from 'express';

const router = Router();

// req.user is populated by requireAuth (applied by route registry)
router.get('/', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const userId = req.user!.id;  // Available because requiresAuth: true
    const subscription = await billingService.getSubscription(userId);
    res.json(subscription);
  } catch (error) {
    next(error);  // Caught by global error handler
  }
});

export const billingRoutes = router;
```

### Backend Route Registration

```typescript
// backend/src/features/billing/route.registration.ts
import { routeRegistry } from '../../config/route.registry.js';
import { billingRoutes } from './billing.routes.js';

routeRegistry.register({
  path: '/billing',
  router: billingRoutes,
  feature: 'billing',
  versions: ['v1'],       // Mounts at /api/v1/billing
  requiresAuth: true,     // requireAuth middleware applied automatically
  description: 'Billing and subscription management',
});
```

### Backend Feature Index

```typescript
// backend/src/features/billing/index.ts
import './route.registration.js';    // Side-effect: registers routes
import './service.registration.js';  // Side-effect: registers service

export { billingService } from './billing.service.js';
```

---

## Auth UI Components

Neon Auth provides pre-built UI components:

### AuthView

Used for sign-in, sign-up, and password reset pages:

```tsx
import { AuthView } from '@neondatabase/neon-js/auth/react/ui';

function AuthPage() {
  return <AuthView pathname={pathname} />;
}
```

Routes:
- `/auth/sign-in` — Sign in form
- `/auth/sign-up` — Registration form
- `/auth/forgot-password` — Password reset request
- `/auth/reset-password` — Password reset form

### AccountView

Used for account settings:

```tsx
import { AccountView } from '@neondatabase/neon-js/auth/react/ui';

function AccountSettings() {
  return <AccountView pathname={pathname} />;
}
```

### SignedIn / SignedOut

Conditional rendering based on auth state:

```tsx
import { SignedIn, SignedOut } from '@/features/auth';

function Header() {
  return (
    <>
      <SignedIn>
        <UserMenu />
      </SignedIn>
      <SignedOut>
        <Link to="/auth/sign-in">Sign In</Link>
      </SignedOut>
    </>
  );
}
```

### UserButton

Quick user menu button:

```tsx
import { UserButton } from '@/features/auth';

function Header() {
  return <UserButton />;
}
```

---

## Sign Out

```tsx
import { authClient } from '@/features/auth';

async function handleSignOut() {
  await authClient.signOut();
  window.location.href = '/auth/sign-in';
}
```

---

## Environment Variables

### Frontend

```env
VITE_NEON_AUTH_URL=https://your-project.neonauth.region.aws.neon.tech/neondb/auth
```

### Backend

```env
NEON_AUTH_URL=https://your-project.neonauth.region.aws.neon.tech/neondb/auth
```

<Aside type="caution">
  Both URLs must match **exactly**, including the `/neondb/auth` path. A mismatch causes token verification failures.
</Aside>

---

## Troubleshooting

### 401 Unauthorised Errors

1. Check `NEON_AUTH_URL` matches exactly in both `.env` files
2. Ensure URL includes the full path (`/neondb/auth`)
3. Verify the JWKS endpoint is accessible: `curl <NEON_AUTH_URL>/.well-known/jwks.json`
4. Check the token is being sent (Network tab → Request Headers → Authorization)
5. Check the token hasn't expired

### Token Not Refreshing

Neon Auth handles token refresh automatically. If issues occur:
1. Check session expiry in the JWT payload
2. Verify `authClient` is initialised correctly
3. Clear browser storage and re-authenticate

### OAuth Not Working

1. Configure the OAuth provider in the Neon Console
2. Add the correct redirect URLs
3. Enable the provider in `NeonAuthUIProvider`
4. Note: Neon Auth shared development keys don't support OAuth account linking — you need custom OAuth credentials for that

### Session Lost on Page Refresh

1. Check that `authClient` is initialised before rendering
2. Verify session storage isn't being cleared
3. Check for CORS issues with the auth endpoint

---

## Production Considerations

### JWKS Caching

The backend uses `createRemoteJWKSet` from the `jose` library, which automatically:
- Caches public keys from Neon's JWKS endpoint
- Refreshes keys when they rotate
- Handles key lookup efficiently

No additional caching configuration is needed.

### Rate Limiting

Consider adding rate limiting to protect API endpoints:

```typescript
import rateLimit from 'express-rate-limit';

const limiter = rateLimit({
  windowMs: 15 * 60 * 1000,  // 15 minutes
  max: 100,                   // 100 requests per window
  standardHeaders: true,
  legacyHeaders: false,
});

app.use('/api/', limiter);
```

### Security Checklist

- [ ] **HTTPS** — Always use HTTPS in production
- [ ] **CORS** — Restrict `FRONTEND_URL` to your production domain
- [ ] **Rate Limiting** — Add limits to prevent abuse
- [ ] **Auth URL Match** — Verify `VITE_NEON_AUTH_URL` and `NEON_AUTH_URL` are identical
- [ ] **Dependency Audit** — Run `npm audit` regularly

---

## Quick Reference for Module Developers

| Task | How |
|------|-----|
| Make authenticated API calls from frontend | Use `api` from `@/lib/api` — tokens are injected automatically |
| Get current user in a React component | `const { data } = useSession()` then `data?.user` |
| Get user ID in backend route handler | `req.user!.id` (after `requireAuth`) |
| Get user email in backend route handler | `req.user!.email` (after `requireAuth`) |
| Register authenticated backend routes | `routeRegistry.register({ ..., requiresAuth: true })` |
| Add admin-only routes | `routeRegistry.register({ ..., middleware: [requireAdmin] })` |
| Add role-specific routes | `routeRegistry.register({ ..., middleware: [requireRole('editor')] })` |
| Register public routes (no auth) | `routeRegistry.registerPublic({ path, method, handler })` |
| Check role in a handler | Use `attachRole` middleware, then check `req.user?.role` |
| Access another feature's service | `serviceRegistry.get('user')` |
| Validate request body | `validate(MyZodSchema)` middleware |

---

## Next Steps

- [User Feature](/starter-template/user-feature/) — User profiles, settings, and preferences
- [Admin Feature](/starter-template/admin-feature/) — User management and app settings
- [Registry Reference](/starter-template/registries/) — All available extension points
- [Base Registry](/starter-template/base-registry/) — Creating custom registries
