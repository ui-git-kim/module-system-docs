---
title: Architecture
description: Understanding the feature-based architecture and registry pattern
---

import { FileTree } from '@astrojs/starlight/components';

## Overview

The starter template uses a **feature-based architecture** with a **registry pattern** for extensibility. This design enables:

- **Modularity** - Features are self-contained and can be added/removed easily
- **Extensibility** - New functionality integrates via registries without modifying core files
- **Scalability** - Clear boundaries between features prevent coupling

---

## Feature-Based Structure

Code is organised by **domain** rather than by technical layer:

```
features/
├── auth/           # Authentication feature
├── dashboard/      # Dashboard and layout
├── user/           # User profile management
└── settings/       # Settings pages
```

Each feature contains everything it needs:

<FileTree>
- features/[feature]/
  - index.ts (Public exports + registrations)
  - components/ (UI components)
  - pages/ (Page components)
  - hooks/ (React hooks)
  - services/ (API layer)
  - types/ (TypeScript types)
  - registrations/ (Registry registrations)
</FileTree>

---

## Registry Pattern

Registries are the core extensibility mechanism. Instead of modifying central files, features **register** themselves:

```typescript
// In a feature's registration file
navigationRegistry.registerMain({
  id: 'my-feature',
  title: 'My Feature',
  url: '/my-feature',
  icon: MyIcon,
  order: 50,
});
```

### How It Works

1. **Feature imports registration file** (side effect)
2. **Registration file calls registry.register()**
3. **Registry stores the item**
4. **Consumer components subscribe via hooks**
5. **UI updates automatically**

### Available Registries

**Frontend:**
- `navigationRegistry` - Sidebar and user menu
- `dashboardRegistry` - Dashboard widgets
- `settingsPagesRegistry` - Settings pages
- `headerToolbarRegistry` - Header actions
- `filterRegistry` - Data transformation
- `actionRegistry` - Side effects

**Backend:**
- `routeRegistry` - API routes
- `serviceRegistry` - Cross-feature services
- `filterRegistry` - Request/response filters
- `actionRegistry` - Lifecycle hooks

---

## Self-Registration Pattern

Features register via **side-effect imports**:

```typescript
// features/my-feature/index.ts

// Side-effect imports trigger registration
import './navigation.registration';
import './registrations/dashboard.registration';

// Public exports
export { myFeatureRoutes } from './routes.config';
```

When the app imports the feature, registrations happen automatically:

```typescript
// main.tsx
import '@/features/my-feature';  // Triggers registrations
```

---

## Data Flow

```
User Action
    ↓
React Component (uses registry hook)
    ↓
API Service (uses api client)
    ↓
Backend Route (from routeRegistry)
    ↓
Service Layer (from serviceRegistry)
    ↓
Database (Prisma)
```

---

## Key Principles

### 1. Features Own Their Domain

Each feature is responsible for:
- Its own routes
- Its own components
- Its own API endpoints
- Its own database operations

### 2. Communication Via Registries

Features don't import each other directly. Instead:
- Frontend: Register navigation, widgets, settings
- Backend: Register routes, expose services

### 3. No Core File Modifications

Adding a feature should never require editing:
- `routes.tsx` (routes come from features)
- `app.ts` (routes come from registry)
- Layout components (items come from registry)

### 4. Type Safety Throughout

All registries are fully typed:
- Item types define required fields
- Service registry uses declaration merging
- Hooks return typed arrays

---

## Next Steps

- [Project Structure](/starter-template/structure/) - Detailed file layout
- [Base Registry](/starter-template/base-registry/) - How registries work
- [Registries](/starter-template/registries/) - All available registries
