---
title: Architecture
description: How the starter template is structured
---

import { FileTree, Tabs, TabItem } from '@astrojs/starlight/components';

## Overview

The starter template is a fullstack TypeScript application with a clear separation between frontend and backend, connected through a REST API.

```
┌─────────────────────────────────────────────────────────────────┐
│                         Frontend (Vite)                          │
│  React 19 · TypeScript · Tailwind v4 · shadcn/ui                │
│                                                                  │
│  features/                                                       │
│  ├── auth/        Session, sign-in UI, route protection         │
│  ├── user/        Profile, avatar, preferences                  │
│  ├── dashboard/   Layout shell, sidebar, header                 │
│  └── admin/       App settings, branding, user management       │
└──────────────────────────┬──────────────────────────────────────┘
                           │ REST API (JWT auth)
                           ▼
┌─────────────────────────────────────────────────────────────────┐
│                       Backend (Express)                          │
│  TypeScript · Prisma 7 · Neon PostgreSQL                        │
│                                                                  │
│  features/                                                       │
│  ├── auth/        JWKS verification middleware                  │
│  ├── user/        Profile CRUD, role management                 │
│  └── admin/       App settings, navigation overrides            │
└──────────────────────────┬──────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────────┐
│                     Neon PostgreSQL                              │
│  User · Profile · AppSettings tables                            │
└─────────────────────────────────────────────────────────────────┘
```

---

## Feature-Based Organisation

Both frontend and backend organise code by **feature** (domain) rather than by technical layer. This keeps related code together and makes features self-contained.

<Tabs>
  <TabItem label="Frontend">
    <FileTree>
    - frontend/src/
      - features/
        - auth/
          - index.ts (exports)
          - components/ (AuthUI, SignIn, etc.)
          - pages/ (SignInPage)
          - lib/ (getAuthToken, session helpers)
          - routes.config.tsx
        - user/
          - index.ts
          - components/ (UserAvatar, ProfileForm)
          - pages/ (ProfilePage, PreferencesPage)
          - hooks/ (useUserProfile)
          - services/ (user.service.ts)
          - context/ (UserProfileProvider)
        - dashboard/
          - index.ts
          - components/ (AppSidebar, HeaderToolbar)
          - pages/ (DashboardPage)
          - navigation.registration.ts
        - admin/
          - index.ts
          - pages/ (AppSettingsPage, UserManagementPage)
          - context/ (AppSettingsContext)
          - hooks/ (useAppSettings)
      - config/ (registries)
      - components/ui/ (shadcn components)
      - lib/ (api client, utilities)
    </FileTree>
  </TabItem>
  <TabItem label="Backend">
    <FileTree>
    - backend/src/
      - features/
        - user/
          - index.ts (exports + registration imports)
          - user.routes.ts (GET/PATCH /profile)
          - user.service.ts (business logic)
          - user.types.ts
          - route.registration.ts
          - service.registration.ts
        - admin/
          - index.ts
          - admin.routes.ts (GET/PATCH /settings)
          - admin.service.ts
          - route.registration.ts
      - config/ (registries)
      - middleware/ (auth, error handling)
      - lib/ (prisma client, errors)
      - prisma/
        - schema.prisma
    </FileTree>
  </TabItem>
</Tabs>

---

## Built-in Features

The starter includes four core features:

| Feature | Frontend | Backend |
|---------|----------|---------|
| **Auth** | Sign-in UI, session hooks, route protection | JWT verification, role middleware |
| **User** | Profile pages, avatar, preferences | Profile CRUD, role management |
| **Dashboard** | Sidebar, header, layout shell | — |
| **Admin** | App settings, user management | Settings API (split permissions) |

See [Built-in Features](/starter-template/features/) for detailed documentation on each.

---

## How Features Connect

```
┌─────────────────────────────────────────────────────────────────┐
│                        DashboardPage                             │
│                                                                  │
│   Wraps with: AppSettingsProvider → UserProfileProvider          │
│                                                                  │
│   ┌─────────────────┐    ┌──────────────────────────────────┐   │
│   │   AppSidebar    │    │           Header                  │   │
│   │                 │    │   ┌──────────────────────────┐   │   │
│   │ • Logo/name     │    │   │     HeaderToolbar        │   │   │
│   │   (from Admin)  │    │   │     (from registry,      │   │   │
│   │                 │    │   │      filtered by Admin)  │   │   │
│   │ • Nav items     │    │   └──────────────────────────┘   │   │
│   │   (from registry│    ├──────────────────────────────────┤   │
│   │    filtered by  │    │           Content                │   │
│   │    Admin)       │    │                                  │   │
│   │                 │    │   Routes render here             │   │
│   │ • User menu     │    │   (profile, settings, etc.)      │   │
│   │   (from User)   │    │                                  │   │
│   └─────────────────┘    └──────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

**Data sources:**
- **AppSettingsProvider** fetches `GET /api/v1/admin/settings` (public) for branding
- **UserProfileProvider** fetches `GET /api/v1/user/profile` for user data
- **Registries** provide navigation items, toolbar actions, widgets

---

## Request Flow

When a user loads their profile:

```
1. Frontend: useUserProfile() hook triggers
         ↓
2. Frontend: api.get('/api/v1/user/profile')
         ↓
3. Frontend: Axios interceptor adds JWT from getAuthToken()
         ↓
4. Backend: requireAuth middleware verifies JWT via JWKS
         ↓
5. Backend: attachRole middleware adds user.role from database
         ↓
6. Backend: Route handler calls userService.getOrCreateProfile()
         ↓
7. Backend: Prisma queries Profile table
         ↓
8. Response flows back, hook updates state, UI renders
```

---

## Database Schema

The starter includes these core tables:

```prisma
model User {
  id        String   @id              // From Neon Auth
  email     String   @unique
  role      Role     @default(user)   // user | admin | managed
  profile   Profile?
  createdAt DateTime @default(now())
}

model Profile {
  id          String  @id @default(cuid())
  userId      String  @unique
  user        User    @relation(...)
  displayName String?
  avatarUrl   String?
  avatarColor String?
  // ... preferences
}

model AppSettings {
  id                  String  @id @default("singleton")
  appName             String?
  logoUrl             String?
  logoDisplayMode     String  @default("both")
  navigationOverrides Json    @default("{}")
  toolbarOverrides    Json    @default("{}")
  // ... more settings
}
```

---

## Key Principles

### 1. Features Own Their Domain

Each feature contains its own routes, components, services, and types. No reaching into other features' internals.

### 2. Extension Via Registries

Features extend the app through registries rather than modifying core files. A module adds a nav item by calling `navigationRegistry.register()`, not by editing the sidebar component.

### 3. Contexts for Shared State

Cross-cutting data (user profile, app settings) is provided via React context at the layout level, available to all child components.

### 4. Split Route Permissions

Some data needs different access levels. The Admin feature demonstrates this: `GET /settings` is public (all users need branding), but `PATCH /settings` requires admin role.

---

## Next Steps

- [Project Structure](/starter-template/structure/) - Detailed file paths
- [Configuration](/starter-template/configuration/) - Environment variables
- [Registry Reference](/starter-template/registries/) - Extension point APIs
