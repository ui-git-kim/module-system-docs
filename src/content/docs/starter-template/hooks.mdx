---
title: Filter & Action Hooks
description: How modules use filters to transform data and actions to run side effects at defined hook points
---

import { Tabs, TabItem, Aside } from '@astrojs/starlight/components';

The starter template provides two hook systems that let modules extend behaviour without modifying core code: **filters** transform data as it passes through a pipeline, and **actions** execute side effects at defined hook points.

Both are available on frontend and backend, with the backend supporting async operations.

---

## Filters vs Actions

| | Filters | Actions |
|---|---------|---------|
| **Purpose** | Transform data | Run side effects |
| **Returns** | Modified value (same type) | Nothing |
| **Pipeline** | Each filter receives previous output | Independent execution |
| **Example** | Modify a user's display name | Send an email after user creation |

---

## Filter Registry

Filters let modules transform data at defined hook points. Each filter receives the output of the previous filter, creating a pipeline.

### Registering a Filter

<Tabs>
  <TabItem label="Frontend">
```typescript
import { filterRegistry } from '@/config/filter.registry';

// Transform user display name (e.g., add title prefix)
filterRegistry.register(
  'user.displayName',      // Hook name
  'titles-module',         // Unique ID for this filter
  (name, ctx) => {         // Transform function
    return ctx.user.title ? `${ctx.user.title} ${name}` : name;
  },
  5  // Order (lower = earlier in pipeline)
);
```
  </TabItem>
  <TabItem label="Backend">
```typescript
import { filterRegistry } from '../../config/filter.registry.js';

// Sync filter
filterRegistry.register(
  'api.user.profile.response',
  'privacy-module',
  (profile) => ({ ...profile, email: maskEmail(profile.email) }),
  20
);

// Async filter (for database lookups or external calls)
filterRegistry.registerAsync(
  'api.user.profile.response',
  'enrichment-module',
  async (profile, ctx) => {
    const stats = await statsService.getUserStats(profile.id);
    return { ...profile, stats };
  }
);
```
  </TabItem>
</Tabs>

### Applying Filters

<Tabs>
  <TabItem label="Frontend">
```typescript
// In a component or utility
const displayName = filterRegistry.apply(
  'user.displayName',
  user.name,
  { user }  // Optional context passed to all filters
);
```
  </TabItem>
  <TabItem label="Backend">
```typescript
// Sync only
const result = filterRegistry.apply('hook.name', value, context);

// Async only
const result = await filterRegistry.applyAsync('hook.name', value, context);

// All filters (sync first, then async)
const result = await filterRegistry.applyAll('hook.name', value, context);
```
  </TabItem>
</Tabs>

### Filter Methods

**Frontend:**

| Method | Description |
|--------|-------------|
| `register(hook, id, callback, order)` | Register a sync filter |
| `unregister(hook, id)` | Remove a filter |
| `apply(hook, value, context)` | Run all filters on a value |
| `hasFilters(hook)` | Check if any filters are registered |
| `getHooks()` | List all hook names |
| `getFilterCount(hook)` | Count filters for a hook |
| `getFilterIds(hook)` | List filter IDs for a hook |

**Backend (additional methods):**

| Method | Description |
|--------|-------------|
| `registerAsync(hook, id, callback, order)` | Register an async filter |
| `unregisterAsync(hook, id)` | Remove an async filter |
| `applyAsync(hook, value, context)` | Run async filters only |
| `applyAll(hook, value, context)` | Run sync then async filters |

### Hook Naming Convention

| Pattern | Examples |
|---------|----------|
| Frontend: `user.{property}` | `user.displayName`, `user.avatarUrl` |
| Frontend: `dashboard.{element}` | `dashboard.widgets` |
| Frontend: `theme.cssVariables` | CSS variable injection |
| Backend: `api.{feature}.{action}.response` | `api.user.profile.response` |
| Backend: `api.{feature}.{action}.request` | `api.user.update.request` |

---

## Action Registry

Actions let modules run side effects at defined hook points. Unlike filters, actions don't return values — they execute independently.

### Registering an Action

<Tabs>
  <TabItem label="Frontend">
```typescript
import { actionRegistry } from '@/config/action.registry';

// Analytics tracking when user logs in
actionRegistry.addAction('user.loggedIn', 'analytics', (ctx) => {
  trackEvent('login', { userId: ctx.user.id });
});

// Show toast when settings are saved
actionRegistry.addAction('settings.saved', 'notifications', (ctx) => {
  showToast('Settings saved successfully');
});
```
  </TabItem>
  <TabItem label="Backend">
```typescript
import { actionRegistry } from '../../config/action.registry.js';

// Sync action (fire-and-forget)
actionRegistry.addAction('user.created', 'audit', (ctx) => {
  auditLog.record('USER_CREATED', { userId: ctx.userId });
});

// Async action (awaited when using doActionAll)
actionRegistry.addActionAsync('user.created', 'welcome-email', async (ctx) => {
  await sendWelcomeEmail(ctx.email);
});
```
  </TabItem>
</Tabs>

### Firing Actions

<Tabs>
  <TabItem label="Frontend">
```typescript
// Fire all sync actions
actionRegistry.doAction('user.loggedIn', { user, method: 'email' });
```
  </TabItem>
  <TabItem label="Backend">
```typescript
// Sync only (non-blocking)
actionRegistry.doAction('admin.settingsUpdated', { settings });

// Async only (sequential)
await actionRegistry.doActionAsync('user.created', { userId, email });

// All actions (sync first, then async — most common)
await actionRegistry.doActionAll('user.created', { userId, email, role });

// Async in parallel (for independent operations)
await actionRegistry.doActionParallel('notifications.send', { items });
```
  </TabItem>
</Tabs>

### Action Methods

| Method | Description |
|--------|-------------|
| `addAction(hook, id, callback, order)` | Register a sync action |
| `addActionAsync(hook, id, callback, order)` | Register an async action |
| `removeAction(hook, id)` | Remove an action |
| `doAction(hook, context)` | Fire sync actions only |
| `doActionAsync(hook, context)` | Fire async actions sequentially |
| `doActionAll(hook, context)` | Fire sync then async |
| `doActionParallel(hook, context)` | Fire async in parallel |
| `hasActions(hook)` | Check if any actions are registered |
| `getHooks()` | List all hook names |

---

## Available Backend Hooks

The starter template fires these action hooks in the user and admin services. All fire after the successful database operation.

### User Service Hooks

| Hook | Execution | Context |
|------|-----------|---------|
| `user.created` | `await doActionAll` | `{ userId, email, role, isFirstUser }` |
| `user.roleUpdated` | `doAction` | `{ userId, previousRole, newRole }` |
| `user.profileUpdated` | `doAction` | `{ userId, fields }` |
| `user.preferencesUpdated` | `doAction` | `{ userId }` |
| `user.deleted` | `await doActionAll` | `{ userId, email, deletionRecord }` |

### Admin Service Hooks

| Hook | Execution | Context |
|------|-----------|---------|
| `admin.settingsUpdated` | `doAction` | `{ settings }` |
| `admin.navigationUpdated` | `doAction` | `{ overrides }` |
| `admin.toolbarUpdated` | `doAction` | `{ overrides }` |
| `user.roleUpdated` | `doAction` | `{ userId, previousRole, newRole, updatedBy }` |
| `user.deleted` | `await doActionAll` | `{ userId, deletedBy }` |

<Aside type="tip">
**Awaited vs fire-and-forget:** Hooks using `doActionAll` (like `user.created` and `user.deleted`) are awaited — the response waits for all async actions to complete. Use `addActionAsync` when your module needs to finish setup or cleanup before the response returns. Hooks using `doAction` are sync and non-blocking.
</Aside>

<Aside type="note">
The admin service fires the **same hook names** as the user service for shared operations (role updates, user deletion). Context fields like `updatedBy` and `deletedBy` distinguish the source.
</Aside>

### Frontend Hooks

The frontend action registry currently fires the `theme.changed` hook (see [Theme Utilities](/starter-template/theme/)). Additional frontend hooks are planned.

---

## Order Convention

Both filter and action registries use the unified **0-100 ordering scale**:

| Range | Label | Use for |
|-------|-------|---------|
| 0-25 | Core | Validation, security checks |
| 26-50 | Feature | Main business logic |
| 51-75 | Secondary | Enrichment, formatting |
| 76-100 | Utility | Logging, analytics |

The default order is **50** if not specified. Lower numbers execute first.

---

## Example: Module Using Both

Here's a complete example of a module using both filters and actions:

```typescript
// modules/analytics/hooks.registration.ts
import { actionRegistry } from '../../config/action.registry.js';
import { filterRegistry } from '../../config/filter.registry.js';

// Track user creation (action — side effect)
actionRegistry.addActionAsync('user.created', 'analytics', async (ctx) => {
  await analytics.track('user_signed_up', {
    userId: ctx.userId,
    isFirstUser: ctx.isFirstUser,
  });
});

// Add analytics metadata to profile responses (filter — transforms data)
filterRegistry.register(
  'api.user.profile.response',
  'analytics',
  (profile) => ({
    ...profile,
    lastActiveAt: analyticsCache.getLastActive(profile.id),
  }),
  60  // Run after core filters
);
```

---

## Next Steps

- [Theme Utilities](/starter-template/theme/) — Uses filters and actions for CSS variable management
- [Registry Reference](/starter-template/registries/) — All available registries
- [Base Registry](/starter-template/base-registry/) — Creating custom registries
