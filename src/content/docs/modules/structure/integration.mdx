---
title: Integration
description: How other modules depend on and integrate with the Structure module
sidebar:
  order: 3
---

import { Steps, Tabs, TabItem, Aside, Card, CardGrid } from '@astrojs/starlight/components';

Structure is the organisational backbone of every app built on the starter template. It defines the "things" users work with — Clients, Projects, Properties, Matters — and provides a universal system for organising, displaying, and navigating them. **Almost every module you build will integrate with Structure.**

This page is the definitive guide for module developers who need to extend, reference, or react to Structure nodes.

---

## How Modules Use Structure

There are three levels of integration, and most modules use all three:

### 1. Attach UI to Nodes (Frontend Registries)

Your module adds tabs, widgets, actions, columns, filters, and sidebar sections to Structure's node pages. For example, a Tasks module adds a "Tasks" tab to every project's detail page, a task count badge on project cards, and a "Task Status" filter on list pages. This is done entirely through **8 frontend registries** — you register components, and Structure renders them in the right place.

### 2. React to Node Events (Backend Action Hooks)

When nodes are created, updated, deleted, moved, or archived, Structure fires **16 action hooks**. Your module listens to these events and reacts: clean up tasks when a project is deleted, generate an invoice when a client is archived, send a notification when a node is moved. This is the primary mechanism for **cross-module coordination**.

### 3. Transform Node Data (Backend Filter Hooks)

Your module can transform Structure data as it flows through the system — enrich node responses with billing status, modify list queries to exclude certain types, or validate node data before creation. This uses **4 filter hooks** that run in a pipeline.

<Aside type="caution" title="Action hooks are the key to module integration">
Without action hooks, modules are islands — they can display UI on nodes but can't react to what happens to those nodes. With action hooks, your module stays in sync: when a node is deleted, your module's related data is cleaned up. When a node is created, your module can set up defaults. This is what makes the module system truly composable.
</Aside>

---

## Integration Points at a Glance

<CardGrid>
  <Card title="React to Events" icon="rocket">
    Hook into 16 lifecycle events — run logic when nodes are created, updated, deleted, moved, archived, or connected.
  </Card>
  <Card title="Add Tabs & Widgets" icon="list-format">
    Add tabs to node detail pages, widgets to the Overview tab, and sections to the sidebar.
  </Card>
  <Card title="Add Actions & Columns" icon="puzzle">
    Add action buttons to nodes, custom columns to table views, and filter controls to list pages.
  </Card>
  <Card title="Register Node Types" icon="document">
    Your module can define its own node types that appear in Structure's hierarchy and navigation.
  </Card>
</CardGrid>

| Integration | Frontend | Backend | Registry |
|-------------|----------|---------|----------|
| Add tabs to detail pages | ✅ | — | `nodeTabRegistry` |
| Add widgets to Overview tab | ✅ | — | `nodeWidgetRegistry` |
| Add badges/actions to cards | ✅ | — | `nodeCardExtensionRegistry` |
| Add action buttons to nodes | ✅ | — | `nodeActionRegistry` |
| Add columns to table views | ✅ | — | `nodeColumnRegistry` |
| Add filter controls to list pages | ✅ | — | `nodeFilterRegistry` |
| Add sidebar sections to detail pages | ✅ | — | `nodeSidebarSectionRegistry` |
| Register custom field types | ✅ | — | `nodeFieldTypeRegistry` |
| Register new node types | ✅ | ✅ | `nodeTypeRegistry` + `structureService` |
| Reference nodes (NodeSelector) | ✅ | — | Component import |
| Customise UI labels per type | ✅ | — | `getLabel()` utility |
| Access Structure data at runtime | — | ✅ | `serviceRegistry.get('structure')` |
| Transform Structure data (filters) | — | ✅ | `filterRegistry` |
| React to Structure events (actions) | — | ✅ | `actionRegistry` |

---

## Declaring the Dependency

If your module depends on Structure, declare it in your `module.ts`:

```typescript
// src/module.ts
export const moduleDefinition: ModuleDefinition = {
  id: 'tasks',
  name: 'Tasks',
  version: '1.0.0',
  dependencies: ['structure'],
  // ...
};
```

This ensures Structure is installed first and lets the scaffold validate the dependency at install time.

---

## Frontend Integration

### Adding Tabs to Node Detail Pages

This is the most common integration. Your module adds a tab that appears on specific (or all) node types.

<Steps>

1. **Create your tab component**

    ```typescript
    // frontend/src/features/tasks/components/TasksTab.tsx
    import { useParams } from 'react-router-dom';

    interface TasksTabProps {
      node: { id: string; nodeType: string };
    }

    export function TasksTab({ node }: TasksTabProps) {
      // Your tab content - fetch tasks for this node, display them, etc.
      return (
        <div>
          <h3>Tasks for {node.id}</h3>
          {/* Your task list, create button, etc. */}
        </div>
      );
    }
    ```

2. **Register the tab**

    ```typescript
    // frontend/src/features/tasks/registrations/structure-tabs.registration.ts
    import { nodeTabRegistry } from '@/features/structure';
    import { TasksTab } from '../components/TasksTab';

    nodeTabRegistry.register({
      id: 'tasks',
      moduleId: 'tasks',
      label: 'Tasks',
      icon: 'CheckSquare',
      nodeTypes: '*',           // Show on all node types, or ['project', 'client']
      order: 30,                // Position in tab bar (10-29 = primary, 30-49 = main)
      component: TasksTab,
      // Optional: dynamic visibility
      // isVisible: (node, nodeTypeConfig) => nodeTypeConfig.features?.tasks !== false,
    });
    ```

3. **Import the registration in your feature index**

    ```typescript
    // frontend/src/features/tasks/index.ts

    // Side-effect imports (registrations) FIRST
    import './registrations/structure-tabs.registration';

    // Then public exports
    export { taskRoutes } from './routes.config';
    ```

</Steps>

<Aside type="note" title="Tab ordering">
Structure's built-in tabs use orders 10-25. Place your tabs at 30+ to appear after the defaults. Use the [order value ranges](/getting-started/llm-rules/) from the LLM rules for consistency.
</Aside>

### Adding Widgets to the Overview Tab

Widgets appear on a node's Overview tab in a configurable layout.

```typescript
// frontend/src/features/activity/registrations/structure-widgets.registration.ts
import { nodeWidgetRegistry } from '@/features/structure';
import { RecentActivityWidget } from '../components/RecentActivityWidget';

nodeWidgetRegistry.register({
  id: 'recent-activity',
  moduleId: 'activity',
  title: 'Recent Activity',
  nodeTypes: '*',
  order: 10,
  component: RecentActivityWidget,
});
```

Your widget component receives the same `{ node }` prop as tabs.

### Adding Badges or Actions to Node Cards

Extend how nodes appear in list/grid views.

```typescript
// frontend/src/features/tasks/registrations/structure-cards.registration.ts
import { nodeCardExtensionRegistry } from '@/features/structure';
import { TaskCountBadge } from '../components/TaskCountBadge';

nodeCardExtensionRegistry.register({
  id: 'task-count',
  moduleId: 'tasks',
  type: 'badge',           // 'badge' | 'action' | 'header' | 'content' | 'footer'
  nodeTypes: '*',
  order: 10,
  component: TaskCountBadge,
});
```

### Adding Action Buttons to Nodes

Add buttons to node detail headers, context menus, or bulk action bars.

```typescript
// frontend/src/features/invoicing/registrations/structure-actions.registration.ts
import { nodeActionRegistry } from '@/features/structure';

nodeActionRegistry.register({
  id: 'generate-invoice',
  moduleId: 'invoicing',
  label: 'Generate Invoice',
  icon: 'Receipt',
  nodeTypes: ['client', 'project'],
  location: 'detail-header',
  variant: 'default',
  order: 30,
  handler: async (node) => {
    await invoicingService.generateForNode(node.id);
  },
  confirm: {
    title: 'Generate Invoice?',
    description: 'This will create a new invoice for all unbilled items.',
  },
});
```

### Adding Columns to Table Views

Register custom columns that appear in the table view on list pages.

```typescript
// frontend/src/features/tasks/registrations/structure-columns.registration.ts
import { nodeColumnRegistry } from '@/features/structure';

nodeColumnRegistry.register({
  id: 'open-tasks',
  moduleId: 'tasks',
  label: 'Open Tasks',
  nodeTypes: ['project'],
  order: 40,
  width: '100px',
  alignment: 'center',
  sortable: true,
  render: (node) => <span>{node.metadata?.openTaskCount ?? 0}</span>,
});
```

### Adding Filter Controls to List Pages

Register filter UI controls for list pages. Filters can operate client-side or server-side.

```typescript
// frontend/src/features/tasks/registrations/structure-filters.registration.ts
import { nodeFilterRegistry } from '@/features/structure';
import { TaskStatusFilter } from '../components/TaskStatusFilter';

nodeFilterRegistry.register({
  id: 'task-status',
  moduleId: 'tasks',
  label: 'Task Status',
  icon: 'Filter',
  nodeTypes: ['project'],
  mode: 'client',
  order: 30,
  component: TaskStatusFilter,
  filterFn: (node, filterValue) => {
    if (!filterValue) return true;
    return node.metadata?.taskStatus === filterValue;
  },
});
```

### Adding Sidebar Sections

Add custom sections to the detail page sidebar (when using sidebar navigation style).

```typescript
// frontend/src/features/tasks/registrations/structure-sidebar.registration.ts
import { nodeSidebarSectionRegistry } from '@/features/structure';
import { TaskSummarySection } from '../components/TaskSummarySection';

nodeSidebarSectionRegistry.register({
  id: 'task-summary',
  moduleId: 'tasks',
  label: 'Task Summary',
  icon: 'CheckSquare',
  nodeTypes: ['project'],
  order: 30,
  collapsible: true,
  defaultCollapsed: false,
  component: TaskSummarySection,
});
```

### Registering Custom Field Types

Extend the field editor system with custom field types. Structure includes 13 built-in types; your module can add more.

```typescript
// frontend/src/features/editor/registrations/structure-fields.registration.ts
import { nodeFieldTypeRegistry } from '@/features/structure';
import { RichTextEditor, RichTextDisplay } from '../components/RichTextEditor';

nodeFieldTypeRegistry.register({
  id: 'rich-text',
  moduleId: 'editor',
  label: 'Rich Text',
  category: 'content',
  icon: 'Type',
  nodeTypes: '*',
  order: 50,
  component: RichTextEditor,
  displayComponent: RichTextDisplay,
});
```

Once registered, the `NodeFieldRenderer` automatically picks up your custom field type. Admins can assign it to fields in the node type configuration.

### Using NodeSelector to Reference Nodes

If your module needs users to pick a Structure node (e.g., linking a task to a project), use the `NodeSelector` component:

```typescript
import { NodeSelector } from '@/features/structure';

function TaskForm() {
  const [selectedNodeId, setSelectedNodeId] = useState<string | null>(null);

  return (
    <NodeSelector
      value={selectedNodeId}
      onChange={setSelectedNodeId}
      allowedTypes={['project', 'client']}  // Optional: restrict to certain types
      placeholder="Select a project..."
    />
  );
}
```

`NodeSelector` provides a searchable dialog with type filtering. It's the recommended way for any module to reference Structure nodes.

### Importing Structure Types

```typescript
// Import types for use in your module
import type { StructureNode, NodeTypeConfig } from '@/features/structure';

// Import hooks for reading Structure data
import { useNodes, useNode, useNodeTypes } from '@/features/structure';

// Import registries for extension
import {
  nodeTabRegistry,
  nodeWidgetRegistry,
  nodeCardExtensionRegistry,
  nodeActionRegistry,
  nodeFieldTypeRegistry,
  nodeColumnRegistry,
  nodeFilterRegistry,
  nodeSidebarSectionRegistry,
} from '@/features/structure';

// Import label utility for customised UI text
import { getLabel } from '@/features/structure';
```

---

## Frontend Registry API Reference

This section documents every configuration property for each frontend registry. Use this as a reference when writing registration code.

<Aside type="tip" title="Common patterns across all registries">
All registrations share these properties: `id` (unique identifier), `moduleId` (your module's ID), `nodeTypes` (`'*'` for all types or `string[]` of slugs), and `order` (display order, default 50). Structure's built-in items use orders 10-25, so place yours at 30+.
</Aside>

### nodeTabRegistry

Adds tabs to node detail pages.

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `id` | `string` | ✅ | Unique tab identifier |
| `moduleId` | `string` | ✅ | Your module's ID |
| `label` | `string` | ✅ | Tab display label |
| `icon` | `string` | — | Lucide icon name |
| `nodeTypes` | `string[] \| '*'` | ✅ | Which node types show this tab |
| `order` | `number` | — | Position in tab bar (default 50) |
| `component` | `ComponentType<NodeTabProps>` | ✅ | React component receiving `{ node, nodeType }` |
| `getBadge` | `(nodeId: string) => Promise<string \| number \| null>` | — | Async badge count/text shown on the tab |
| `isVisible` | `(node, nodeType) => boolean` | — | Dynamic visibility based on node state |

**Component props:** Your tab component receives `{ node: StructureNode, nodeType: NodeTypeConfig }`.

### nodeWidgetRegistry

Adds widgets to the Overview tab, dashboard, or node sidebar.

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `id` | `string` | ✅ | Unique widget identifier |
| `moduleId` | `string` | ✅ | Your module's ID |
| `title` | `string` | ✅ | Widget display title |
| `icon` | `string` | — | Lucide icon name |
| `location` | `'node-overview' \| 'dashboard' \| 'node-sidebar'` | ✅ | Where the widget renders |
| `nodeTypes` | `string[] \| '*'` | — | Which node types show this widget |
| `size` | `'1x1' \| '2x1' \| '1x2' \| '2x2' \| 'full'` | — | Widget size in the grid layout |
| `order` | `number` | — | Position in widget layout (default 50) |
| `component` | `ComponentType<NodeWidgetProps>` | ✅ | React component receiving `{ node?, nodeType?, size }` |
| `isVisible` | `(node, nodeType) => boolean` | — | Dynamic visibility based on node state |

### nodeCardExtensionRegistry

Extends node cards in grid and list views. Each extension renders in one of 5 positions on the card.

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `id` | `string` | ✅ | Unique extension identifier |
| `moduleId` | `string` | ✅ | Your module's ID |
| `nodeTypes` | `string[] \| '*'` | ✅ | Which node types show this extension |
| `position` | `CardExtensionPosition` | ✅ | Where on the card to render (see table below) |
| `order` | `number` | — | Position order within the slot (default 50) |
| `render` | `(node: StructureNode) => ReactNode` | ✅ | Render function returning JSX |

**Card extension positions:**

| Position | shadcn Card Part | Description | Example Use |
|----------|-----------------|-------------|-------------|
| `badge` | `CardHeader` (top-right) | Small status indicators | Task count, status dot, priority flag |
| `action` | `CardHeader` (actions area) | Interactive buttons/icons | Quick-add, bookmark, share |
| `header` | Below `CardHeader` | Additional header content | Progress bar, subtitle, tags |
| `content` | `CardContent` | Main card body extension | Preview text, thumbnail, summary stats |
| `footer` | `CardFooter` | Bottom of card | Metadata, timestamps, assignees |

Admins can move extensions between positions via the admin panel.

### nodeActionRegistry

Adds action buttons to node detail headers, context menus, and bulk action bars.

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `id` | `string` | ✅ | Unique action identifier |
| `moduleId` | `string` | ✅ | Your module's ID |
| `label` | `string` | ✅ | Button/menu item label |
| `icon` | `string` | — | Lucide icon name |
| `nodeTypes` | `string[] \| '*'` | ✅ | Which node types show this action |
| `locations` | `NodeActionLocation[]` | ✅ | `'detail-header'`, `'context-menu'`, `'bulk-action'` |
| `order` | `number` | — | Position in action list (default 50) |
| `variant` | `'default' \| 'destructive' \| 'secondary'` | — | Button style variant |
| `handler` | `(node, nodeType) => Promise<void>` | ✅ | Single-node action handler |
| `bulkHandler` | `(nodes[], nodeType) => Promise<void>` | — | Bulk action handler for multiple nodes |
| `isVisible` | `(node, nodeType) => boolean` | — | Dynamic visibility |
| `confirm` | `{ title, description, confirmLabel?, variant? }` | — | Show confirmation dialog before executing |
| `shortcut` | `string` | — | Keyboard shortcut (e.g., `'mod+shift+i'`) |
| `disabled` | `boolean \| (node, nodeType) => boolean` | — | Disable the action |

### nodeColumnRegistry

Adds columns to table view on list pages.

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `id` | `string` | ✅ | Unique column identifier |
| `moduleId` | `string` | ✅ | Your module's ID |
| `label` | `string` | ✅ | Column header text |
| `nodeTypes` | `string[] \| '*'` | ✅ | Which node types show this column |
| `order` | `number` | — | Column position (default 50) |
| `render` | `(node, nodeType) => ReactNode` | ✅ | Cell render function |
| `renderCompact` | `(node) => ReactNode` | — | Compact render for card/list views |
| `width` | `string` | — | CSS width (`'120px'`, `'15%'`, `'auto'`) |
| `minWidth` | `string` | — | CSS min-width |
| `alignment` | `'left' \| 'center' \| 'right'` | — | Text alignment (default `'left'`) |
| `sortable` | `boolean` | — | Whether users can sort by this column |
| `getSortValue` | `(node) => string \| number` | — | Custom sort value extractor |
| `isVisible` | `(nodeType) => boolean` | — | Dynamic visibility |
| `needsPrefetch` | `boolean` | — | Whether data must be loaded before rendering |
| `prefetch` | `(nodeIds: string[]) => Promise<void>` | — | Batch data loader for multiple nodes |

<Aside type="tip" title="Prefetch for performance">
If your column displays data from your module's API (e.g., task count per node), use `needsPrefetch: true` and `prefetch` to batch-load data for all visible nodes in one request, rather than making per-row API calls.
</Aside>

### nodeFilterRegistry

Adds filter controls to list page filter bars. Supports client-side or server-side filtering.

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `id` | `string` | ✅ | Unique filter identifier |
| `moduleId` | `string` | ✅ | Your module's ID |
| `label` | `string` | ✅ | Filter label in the filter bar |
| `icon` | `string` | — | Lucide icon name |
| `nodeTypes` | `string[] \| '*'` | ✅ | Which node types show this filter |
| `order` | `number` | — | Position in filter bar (default 50) |
| `mode` | `'client' \| 'server'` | ✅ | Client-side filtering or server-side query params |
| `component` | `ComponentType<FilterRenderProps>` | ✅ | Filter UI component |
| `filterFn` | `(node, filterValue) => boolean` | — | Client-side filter function (required when `mode: 'client'`) |
| `toQueryParams` | `(filterValue) => Record<string, string>` | — | Convert filter value to API query params (required when `mode: 'server'`) |
| `isVisible` | `(nodeType) => boolean` | — | Dynamic visibility |

**Filter component props:** `{ value, onChange, nodeType, nodes? }`

### nodeSidebarSectionRegistry

Adds sections to the detail page sidebar (when using sidebar navigation style).

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `id` | `string` | ✅ | Unique section identifier |
| `moduleId` | `string` | ✅ | Your module's ID |
| `title` | `string` | ✅ | Section display title |
| `icon` | `string` | — | Lucide icon name |
| `nodeTypes` | `string[] \| '*'` | ✅ | Which node types show this section |
| `order` | `number` | — | Position in sidebar (default 50) |
| `component` | `ComponentType<{ node, nodeType }>` | ✅ | Section content component |
| `collapsible` | `boolean` | — | Whether section can collapse (default `true`) |
| `defaultCollapsed` | `boolean` | — | Start collapsed? (default `false`) |
| `isVisible` | `(node, nodeType) => boolean` | — | Dynamic visibility |

### nodeFieldTypeRegistry

Extends the field type system with custom field types beyond the 13 built-in types.

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `id` | `string` | ✅ | Field type identifier (e.g., `'rich-text'`, `'map-location'`) |
| `moduleId` | `string` | ✅ | Your module's ID |
| `label` | `string` | ✅ | Human-readable name shown in admin field picker |
| `icon` | `string` | — | Lucide icon for the field type picker |
| `description` | `string` | — | Help text in admin field type selector |
| `category` | `'text' \| 'media' \| 'reference' \| 'layout' \| 'custom'` | — | Field categorisation |
| `order` | `number` | — | Position in field type picker (default 50) |
| `component` | `ComponentType<FieldTypeRenderProps>` | ✅ | Form field component for editing |
| `displayComponent` | `ComponentType<FieldTypeDisplayProps>` | — | Read-only display for cards/columns |
| `validate` | `(value, fieldConfig) => string \| null` | — | Custom validation (return error string or null) |
| `transformBeforeSave` | `(value) => unknown` | — | Transform value before saving to database |
| `getDefaultValue` | `() => unknown` | — | Factory for default field value |
| `configSchema` | `NodeTypeField[]` | — | Additional config fields shown in admin when this type is selected |

**Component props:**
- Edit: `{ field: NodeTypeField, value: unknown, onChange: (value) => void, error?: string, disabled?: boolean }`
- Display: `{ field: NodeTypeField, value: unknown }`

### NodeTypeRegistry (Database-Synced)

Unlike the 8 registries above (which are code-based), the `NodeTypeRegistry` is synced with the database and provides methods for managing node types at runtime.

| Method | Description |
|--------|-------------|
| `register(config)` | Register a node type configuration |
| `get(slug)` | Get a single node type by slug |
| `getAll()` | Get all registered node types |
| `getEnabledTypes()` | Get only enabled node types, sorted by `sortOrder` |
| `syncFromDatabase(types)` | Sync registry state with database records |
| `onSync(callback)` | Subscribe to sync events — returns an unsubscribe function |

**Reactive hooks:**
- `useEnabledNodeTypes()` — returns enabled types, re-renders on `onSync()`
- `useStructureNavItems()` — returns sidebar navigation items, re-renders on `onSync()`

---

## Backend Integration

### Reacting to Structure Events (Action Hooks)

<Aside type="tip" title="Start here">
Action hooks are the most important backend integration point. If your module only does one backend integration with Structure, it should be this one.
</Aside>

Action hooks fire after every Structure mutation. Your module registers listeners that run automatically when nodes are created, updated, deleted, moved, archived, restored, or connected. This is how modules stay in sync — and it's what makes the module system truly composable.

**Common use cases:**
- **Cleanup on delete** — archive or remove your module's data when the parent node is deleted
- **Setup on create** — create default records when a new node of a specific type is created
- **Sync on update** — update cached data, trigger recalculations, or send notifications
- **Audit trail** — log significant events for compliance or debugging

```typescript
// backend/src/features/tasks/action.registration.ts
import { actionRegistry } from '../../config/action.registry.js';

// Clean up tasks when a node is deleted
actionRegistry.addActionAsync(
  'structure.node.deleted',
  'tasks-cleanup-on-delete',
  async (context) => {
    const { userId, nodeId } = context;
    // Delete or archive tasks associated with this node
    await prisma.task.updateMany({
      where: { nodeId, userId },
      data: { status: 'archived' },
    });
  },
  20
);

// Set up default task list when a node is created
actionRegistry.addActionAsync(
  'structure.node.created',
  'tasks-setup-defaults',
  async (context) => {
    const { userId, node, nodeType } = context;
    if (nodeType === 'project') {
      // Create a default "To Do" task list for new projects
      await prisma.task_list.create({
        data: { nodeId: node.id, userId, name: 'To Do' },
      });
    }
  },
  20
);
```

**Available Structure action hooks:**

| Hook | Context | Fires when |
|------|---------|------------|
| `structure.node.created` | `{ userId, node, nodeType }` | A node is created |
| `structure.node.updated` | `{ userId, node, changes }` | A node is updated |
| `structure.node.deleted` | `{ userId, nodeId, nodeType }` | A node is deleted |
| `structure.node.moved` | `{ userId, node, oldParentId, newParentId }` | A node moves parent |
| `structure.node.archived` | `{ userId, node }` | A node is archived |
| `structure.node.restored` | `{ userId, node }` | A node is restored from archive |
| `structure.node.favorited` | `{ userId, node, isFavorite }` | Favourite is toggled |
| `structure.connection.created` | `{ userId, connection }` | A connection is created |
| `structure.connection.deleted` | `{ userId, connectionId }` | A connection is deleted |
| `structure.nodeType.created` | `{ userId, nodeType }` | A node type is created |
| `structure.nodeType.updated` | `{ userId, slug, changes }` | A node type is updated |
| `structure.nodeType.deleted` | `{ userId, slug }` | A node type is deleted |
| `structure.template.created` | `{ userId, template }` | A template is created |
| `structure.template.updated` | `{ userId, templateId, changes }` | A template is updated |
| `structure.template.deleted` | `{ userId, templateId }` | A template is deleted |
| `structure.settings.updated` | `{ userId, settings }` | User settings are updated |

### Transforming Structure Data (Filter Hooks)

Register filters to modify Structure data as it flows through the system. Filters run in a pipeline — each receives the output of the previous one.

```typescript
// backend/src/features/billing/filter.registration.ts
import { filterRegistry } from '../../config/filter.registry.js';

// Enrich node responses with billing data
filterRegistry.register(
  'structure.node.response',
  'billing-enrich-node',
  (node, context) => {
    // Add billing status to node metadata
    // (actual implementation would fetch from database)
    return {
      ...node,
      metadata: {
        ...node.metadata,
        hasBilling: true,
      },
    };
  },
  20
);

// Modify list queries to exclude certain types
filterRegistry.register(
  'structure.node.listQuery',
  'billing-filter-query',
  (query, context) => {
    // Example: modify the query before it executes
    return query;
  },
  20
);
```

**Available Structure filter hooks:**

| Hook | Receives | Purpose |
|------|----------|---------|
| `structure.node.beforeCreate` | Node input data | Transform data before a node is saved |
| `structure.node.response` | Node object | Enrich node data before sending to client |
| `structure.node.listQuery` | Query parameters | Modify list query before execution |
| `structure.nodeType.response` | Node type object | Transform node type data before sending to client |

### Accessing Structure Data via Service Registry

Other modules access Structure's backend service through the `serviceRegistry` — never by importing directly from the Structure feature folder.

```typescript
// backend/src/features/tasks/tasks.service.ts
import { serviceRegistry } from '../../config/service.registry.js';

export const tasksService = {
  async getTasksForNode(nodeId: string, userId: string) {
    // Access Structure service at runtime
    const structureService = serviceRegistry.get('structure');

    // Verify the node exists and belongs to the user
    const node = await structureService.getNode(nodeId, userId);

    // Now fetch tasks for this node
    return prisma.task.findMany({
      where: { nodeId: node.id, userId },
    });
  },
};
```

<Aside type="caution" title="Never import across module boundaries">
Do NOT import directly from `../../features/structure/structure.service.js`. Always use `serviceRegistry.get('structure')` to access other modules' services. This maintains module isolation and allows the system to detect missing dependencies.
</Aside>

### Registering Node Types from Your Module

If your module introduces its own node type (e.g., a "Task Board" type), register it during backend initialisation:

```typescript
// backend/src/features/tasks/tasks.init.ts
import { serviceRegistry } from '../../config/service.registry.js';

export async function initTasks(): Promise<void> {
  const structureService = serviceRegistry.get('structure');

  // Register a module-specific node type
  const existingTypes = await structureService.listNodeTypes('system', true);
  const hasTaskBoard = existingTypes.some(t => t.slug === 'task-board');

  if (!hasTaskBoard) {
    await structureService.createNodeType('system', {
      slug: 'task-board',
      name: 'Task Board',
      namePlural: 'Task Boards',
      icon: 'Kanban',
      moduleId: 'tasks',
      rules: {
        allowedParents: ['project'],
        allowedChildren: [],
      },
      features: {
        favorites: true,
        archiving: true,
      },
      fields: [],
      navigation: {
        mainNav: { enabled: false },
        sidebarNav: { style: 'none' },
        pageNav: {
          style: 'tabs',
          builtInTabs: {
            overview: false,
            info: true,
            settings: true,
          },
          defaultTab: 'info',
        },
        listPage: { defaultView: 'grid' },
      },
      isSystem: true,
      sortOrder: 40,
    });
  }
}
```

<Aside type="note" title="moduleId matters">
Always set `moduleId` to your module's ID when creating node types. This lets the system know which module owns the type, and enables proper cleanup on module uninstall.
</Aside>

---

## Storing Node References in Your Schema

If your module's database tables need to reference Structure nodes, use a plain `nodeId` string field — not a Prisma `@relation`:

```prisma
model task {
  id        String   @id @default(cuid())
  userId    String
  nodeId    String              // References structure_node.id
  title     String
  status    String   @default("todo")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([nodeId])             // Index for fast lookups by node
  @@index([userId, nodeId])     // Composite for user+node queries
}
```

<Aside type="caution" title="No cross-module @relation">
Module schemas must be self-contained. Use plain string fields with `@@index` for foreign keys to other modules' tables. Never use `@relation` across module boundaries — this would create tight coupling and break independent installation.
</Aside>

---

## Complete Integration Example

Here's how a hypothetical "Tasks" module would integrate with Structure end-to-end:

<Tabs>
  <TabItem label="Frontend">

```
src/features/tasks/
├── index.ts                                    # Side-effect imports first
├── components/
│   ├── TasksTab.tsx                            # Tab content for node detail pages
│   ├── TaskCountBadge.tsx                      # Badge on node cards
│   ├── TaskSummaryWidget.tsx                   # Widget for Overview tab
│   ├── TaskSummarySection.tsx                  # Sidebar section
│   └── TaskStatusFilter.tsx                    # Filter control for list pages
├── registrations/
│   ├── structure-tabs.registration.ts          # Register TasksTab
│   ├── structure-widgets.registration.ts       # Register TaskSummaryWidget
│   ├── structure-cards.registration.ts         # Register TaskCountBadge
│   ├── structure-actions.registration.ts       # Register action buttons
│   ├── structure-columns.registration.ts       # Register table columns
│   ├── structure-filters.registration.ts       # Register filter controls
│   └── structure-sidebar.registration.ts       # Register sidebar sections
└── ...
```

**index.ts:**
```typescript
// Side-effect imports (registrations) FIRST
import './registrations/structure-tabs.registration';
import './registrations/structure-widgets.registration';
import './registrations/structure-cards.registration';
import './registrations/structure-actions.registration';
import './registrations/structure-columns.registration';
import './registrations/structure-filters.registration';
import './registrations/structure-sidebar.registration';

// Then public exports
export { taskRoutes } from './routes.config';
```

  </TabItem>
  <TabItem label="Backend">

```
src/features/tasks/
├── index.ts
├── tasks.routes.ts
├── tasks.service.ts
├── tasks.types.ts
├── tasks.init.ts                               # Register task-board node type
├── route.registration.ts
├── service.registration.ts
├── filter.registration.ts                      # Optional: transform Structure data
└── action.registration.ts                      # React to Structure events
```

**action.registration.ts:**
```typescript
import { actionRegistry } from '../../config/action.registry.js';
import { tasksService } from './tasks.service.js';

// Clean up when nodes are deleted
actionRegistry.addActionAsync(
  'structure.node.deleted',
  'tasks-cleanup',
  async (context) => {
    await tasksService.archiveTasksForNode(context.nodeId, context.userId);
  },
  20
);
```

  </TabItem>
</Tabs>

---

## Admin Control of Module Integrations

Admins can control module-provided content per node type in two places:

1. **Integrations tab** in the node type form (Structure Types > Edit Type > Integrations) — control tabs, widgets, and card extensions per type
2. **Registries tab** on the App Structure admin page — browse all registered items across all 8 registry types (actions, columns, filters, sidebar sections, field types, tabs, widgets, card extensions)

Your module's registered items can be:

- **Enabled/disabled** per node type
- **Renamed** — admins can override the label you provide
- **Reordered** — admins can change the display order
- **Slot reassigned** (card extensions only) — admins can move an extension between card positions

Your module doesn't need to do anything special to support this. The registries automatically check the `integrations` config on each node type before returning results. If an admin disables your action for a particular node type, `getActionsForNode()` simply won't include it.

<Aside type="tip">
Module integrations are discovered at render time from the registries. As modules are installed or removed, the admin UI updates automatically to show available integrations. The Registries tab provides a central view of everything that's been registered across all modules.
</Aside>

---

## Integration Checklist

Use this checklist when building a module that integrates with Structure:

- [ ] **Dependency declared** — `dependencies: ['structure']` in `module.ts`
- [ ] **Frontend registrations** — Tabs, widgets, actions, columns, filters, sidebar sections, and/or card extensions registered via side-effect imports
- [ ] **Backend service access** — Use `serviceRegistry.get('structure')`, never direct imports
- [ ] **Event hooks** — Action registrations for cleanup on node delete, setup on node create
- [ ] **Schema isolation** — Plain `nodeId` string field with `@@index`, no `@relation`
- [ ] **Node types** — If registering types, set `moduleId` to your module ID
- [ ] **Order values** — Tabs/widgets/actions use order 30+ (after Structure's built-in items)
- [ ] **Labels** — Use `getLabel(nodeType, key)` for user-facing text instead of hardcoding type names

---

## Next Steps

- [Usage](/modules/structure/usage/) — Admin page, components, and hooks reference
- [Configuration](/modules/structure/configuration/) — Database schema and API endpoints
- [Developer Workflow](/modules/structure/developer-workflow/) — Setup, building, and testing
