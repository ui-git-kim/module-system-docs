---
title: Module Integration
description: How other modules depend on and integrate with the Structure module
---

import { Steps, Tabs, TabItem, Aside, Card, CardGrid } from '@astrojs/starlight/components';

Most modules in a SaaS application will integrate with Structure. This page is the definitive guide for module developers who need to extend, reference, or react to Structure nodes.

<Aside type="tip" title="Why most modules need Structure">
Structure provides the organisational backbone — the "things" users work with (Clients, Projects, Properties, etc.). Your module almost certainly adds functionality **to** those things: tasks on a project, invoices on a client, documents on a matter. This page shows you exactly how to wire that up.
</Aside>

---

## Integration Points at a Glance

<CardGrid>
  <Card title="Register Node Types" icon="document">
    Your module can define its own node types that appear in Structure's hierarchy and navigation.
  </Card>
  <Card title="Add Tabs" icon="list-format">
    Add tabs to node detail pages — e.g., a "Tasks" tab on every Project node.
  </Card>
  <Card title="Add Widgets" icon="puzzle">
    Add widgets to the Overview tab — e.g., a "Recent Activity" widget.
  </Card>
  <Card title="React to Events" icon="rocket">
    Hook into Structure lifecycle events — e.g., run logic when a node is created or deleted.
  </Card>
</CardGrid>

| Integration | Frontend | Backend | Registry |
|-------------|----------|---------|----------|
| Add tabs to detail pages | ✅ | — | `nodeTabRegistry` |
| Add widgets to Overview tab | ✅ | — | `nodeWidgetRegistry` |
| Add badges/actions to cards | ✅ | — | `nodeCardExtensionRegistry` |
| Register new node types | ✅ | ✅ | `nodeTypeRegistry` + `structureService` |
| Reference nodes (NodeSelector) | ✅ | — | Component import |
| Access Structure data at runtime | — | ✅ | `serviceRegistry.get('structure')` |
| Transform Structure data (filters) | — | ✅ | `filterRegistry` |
| React to Structure events (actions) | — | ✅ | `actionRegistry` |

---

## Declaring the Dependency

If your module depends on Structure, declare it in your `module.ts`:

```typescript
// src/module.ts
export const moduleDefinition: ModuleDefinition = {
  id: 'tasks',
  name: 'Tasks',
  version: '1.0.0',
  dependencies: ['structure'],
  // ...
};
```

This ensures Structure is installed first and lets the scaffold validate the dependency at install time.

---

## Frontend Integration

### Adding Tabs to Node Detail Pages

This is the most common integration. Your module adds a tab that appears on specific (or all) node types.

<Steps>

1. **Create your tab component**

    ```typescript
    // frontend/src/features/tasks/components/TasksTab.tsx
    import { useParams } from 'react-router-dom';

    interface TasksTabProps {
      node: { id: string; nodeType: string };
    }

    export function TasksTab({ node }: TasksTabProps) {
      // Your tab content - fetch tasks for this node, display them, etc.
      return (
        <div>
          <h3>Tasks for {node.id}</h3>
          {/* Your task list, create button, etc. */}
        </div>
      );
    }
    ```

2. **Register the tab**

    ```typescript
    // frontend/src/features/tasks/registrations/structure-tabs.registration.ts
    import { nodeTabRegistry } from '@/features/structure';
    import { TasksTab } from '../components/TasksTab';

    nodeTabRegistry.register({
      id: 'tasks',
      moduleId: 'tasks',
      label: 'Tasks',
      icon: 'CheckSquare',
      nodeTypes: '*',           // Show on all node types, or ['project', 'client']
      order: 30,                // Position in tab bar (10-29 = primary, 30-49 = main)
      component: TasksTab,
      // Optional: dynamic visibility
      // isVisible: (node, nodeTypeConfig) => nodeTypeConfig.features?.tasks !== false,
    });
    ```

3. **Import the registration in your feature index**

    ```typescript
    // frontend/src/features/tasks/index.ts

    // Side-effect imports (registrations) FIRST
    import './registrations/structure-tabs.registration';

    // Then public exports
    export { taskRoutes } from './routes.config';
    ```

</Steps>

<Aside type="note" title="Tab ordering">
Structure's built-in tabs use orders 10-25. Place your tabs at 30+ to appear after the defaults. Use the [order value ranges](/getting-started/llm-rules/) from the LLM rules for consistency.
</Aside>

### Adding Widgets to the Overview Tab

Widgets appear on a node's Overview tab in a configurable layout.

```typescript
// frontend/src/features/activity/registrations/structure-widgets.registration.ts
import { nodeWidgetRegistry } from '@/features/structure';
import { RecentActivityWidget } from '../components/RecentActivityWidget';

nodeWidgetRegistry.register({
  id: 'recent-activity',
  moduleId: 'activity',
  title: 'Recent Activity',
  nodeTypes: '*',
  order: 10,
  component: RecentActivityWidget,
});
```

Your widget component receives the same `{ node }` prop as tabs.

### Adding Badges or Actions to Node Cards

Extend how nodes appear in list/grid views.

```typescript
// frontend/src/features/tasks/registrations/structure-cards.registration.ts
import { nodeCardExtensionRegistry } from '@/features/structure';
import { TaskCountBadge } from '../components/TaskCountBadge';

nodeCardExtensionRegistry.register({
  id: 'task-count',
  moduleId: 'tasks',
  type: 'badge',           // 'badge' | 'action' | 'header' | 'content' | 'footer'
  nodeTypes: '*',
  order: 10,
  component: TaskCountBadge,
});
```

### Using NodeSelector to Reference Nodes

If your module needs users to pick a Structure node (e.g., linking a task to a project), use the `NodeSelector` component:

```typescript
import { NodeSelector } from '@/features/structure';

function TaskForm() {
  const [selectedNodeId, setSelectedNodeId] = useState<string | null>(null);

  return (
    <NodeSelector
      value={selectedNodeId}
      onChange={setSelectedNodeId}
      allowedTypes={['project', 'client']}  // Optional: restrict to certain types
      placeholder="Select a project..."
    />
  );
}
```

`NodeSelector` provides a searchable dialog with type filtering. It's the recommended way for any module to reference Structure nodes.

### Importing Structure Types

```typescript
// Import types for use in your module
import type { StructureNode, NodeTypeConfig } from '@/features/structure';

// Import hooks for reading Structure data
import { useNodes, useNode, useNodeTypes } from '@/features/structure';

// Import registries for extension
import {
  nodeTabRegistry,
  nodeWidgetRegistry,
  nodeCardExtensionRegistry,
} from '@/features/structure';
```

---

## Backend Integration

### Accessing Structure Data via Service Registry

Other modules access Structure's service through the `serviceRegistry` — never by importing directly from the Structure feature folder.

```typescript
// backend/src/features/tasks/tasks.service.ts
import { serviceRegistry } from '../../config/service.registry.js';

export const tasksService = {
  async getTasksForNode(nodeId: string, userId: string) {
    // Access Structure service at runtime
    const structureService = serviceRegistry.get('structure');

    // Verify the node exists and belongs to the user
    const node = await structureService.getNode(nodeId, userId);

    // Now fetch tasks for this node
    return prisma.task.findMany({
      where: { nodeId: node.id, userId },
    });
  },
};
```

<Aside type="caution" title="Never import across module boundaries">
Do NOT import directly from `../../features/structure/structure.service.js`. Always use `serviceRegistry.get('structure')` to access other modules' services. This maintains module isolation and allows the system to detect missing dependencies.
</Aside>

### Reacting to Structure Events (Action Hooks)

Register actions that fire when Structure operations occur. This is how your module stays in sync with Structure changes.

```typescript
// backend/src/features/tasks/action.registration.ts
import { actionRegistry } from '../../config/action.registry.js';

// Clean up tasks when a node is deleted
actionRegistry.addActionAsync(
  'structure.node.deleted',
  'tasks-cleanup-on-delete',
  async (context) => {
    const { userId, nodeId } = context;
    // Delete or archive tasks associated with this node
    await prisma.task.updateMany({
      where: { nodeId, userId },
      data: { status: 'archived' },
    });
  },
  20
);

// Set up default task list when a node is created
actionRegistry.addActionAsync(
  'structure.node.created',
  'tasks-setup-defaults',
  async (context) => {
    const { userId, node, nodeType } = context;
    if (nodeType === 'project') {
      // Create a default "To Do" task list for new projects
      await prisma.task_list.create({
        data: { nodeId: node.id, userId, name: 'To Do' },
      });
    }
  },
  20
);
```

**Available Structure action hooks:**

| Hook | Context | Fires when |
|------|---------|------------|
| `structure.node.created` | `{ userId, node, nodeType }` | A node is created |
| `structure.node.updated` | `{ userId, node, changes }` | A node is updated |
| `structure.node.deleted` | `{ userId, nodeId, nodeType }` | A node is deleted |
| `structure.node.moved` | `{ userId, node, oldParentId, newParentId }` | A node moves parent |
| `structure.node.archived` | `{ userId, node }` | A node is archived |
| `structure.node.restored` | `{ userId, node }` | A node is restored from archive |
| `structure.node.favorited` | `{ userId, node, isFavorite }` | Favourite is toggled |
| `structure.connection.created` | `{ userId, connection }` | A connection is created |
| `structure.connection.deleted` | `{ userId, connectionId }` | A connection is deleted |
| `structure.nodeType.created` | `{ userId, nodeType }` | A node type is created |
| `structure.nodeType.updated` | `{ userId, slug, changes }` | A node type is updated |
| `structure.nodeType.deleted` | `{ userId, slug }` | A node type is deleted |

### Transforming Structure Data (Filter Hooks)

Register filters to modify Structure data as it flows through the system. Filters run in a pipeline — each receives the output of the previous one.

```typescript
// backend/src/features/billing/filter.registration.ts
import { filterRegistry } from '../../config/filter.registry.js';

// Enrich node responses with billing data
filterRegistry.register(
  'structure.node.response',
  'billing-enrich-node',
  (node, context) => {
    // Add billing status to node metadata
    // (actual implementation would fetch from database)
    return {
      ...node,
      metadata: {
        ...node.metadata,
        hasBilling: true,
      },
    };
  },
  20
);

// Modify list queries to exclude certain types
filterRegistry.register(
  'structure.node.listQuery',
  'billing-filter-query',
  (query, context) => {
    // Example: modify the query before it executes
    return query;
  },
  20
);
```

**Available Structure filter hooks:**

| Hook | Receives | Purpose |
|------|----------|---------|
| `structure.node.beforeCreate` | Node input data | Transform data before a node is saved |
| `structure.node.response` | Node object | Enrich node data before sending to client |
| `structure.node.listQuery` | Query parameters | Modify list query before execution |
| `structure.nodeType.response` | Node type object | Transform node type data before sending to client |

### Registering Node Types from Your Module

If your module introduces its own node type (e.g., a "Task Board" type), register it during backend initialisation:

```typescript
// backend/src/features/tasks/tasks.init.ts
import { serviceRegistry } from '../../config/service.registry.js';

export async function initTasks(): Promise<void> {
  const structureService = serviceRegistry.get('structure');

  // Register a module-specific node type
  const existingTypes = await structureService.listNodeTypes('system', true);
  const hasTaskBoard = existingTypes.some(t => t.slug === 'task-board');

  if (!hasTaskBoard) {
    await structureService.createNodeType('system', {
      slug: 'task-board',
      name: 'Task Board',
      namePlural: 'Task Boards',
      icon: 'Kanban',
      moduleId: 'tasks',
      rules: {
        allowedParents: ['project'],
        allowedChildren: [],
      },
      features: {
        favorites: true,
        archiving: true,
      },
      fields: [],
      navigation: {
        mainNav: { enabled: false },
        sidebarNav: { style: 'none' },
        pageNav: {
          style: 'tabs',
          builtInTabs: {
            overview: false,
            info: true,
            settings: true,
          },
          defaultTab: 'info',
        },
        listPage: { defaultView: 'grid' },
      },
      isSystem: true,
      sortOrder: 40,
    });
  }
}
```

<Aside type="note" title="moduleId matters">
Always set `moduleId` to your module's ID when creating node types. This lets the system know which module owns the type, and enables proper cleanup on module uninstall.
</Aside>

---

## Storing Node References in Your Schema

If your module's database tables need to reference Structure nodes, use a plain `nodeId` string field — not a Prisma `@relation`:

```prisma
model task {
  id        String   @id @default(cuid())
  userId    String
  nodeId    String              // References structure_node.id
  title     String
  status    String   @default("todo")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([nodeId])             // Index for fast lookups by node
  @@index([userId, nodeId])     // Composite for user+node queries
}
```

<Aside type="caution" title="No cross-module @relation">
Module schemas must be self-contained. Use plain string fields with `@@index` for foreign keys to other modules' tables. Never use `@relation` across module boundaries — this would create tight coupling and break independent installation.
</Aside>

---

## Complete Integration Example

Here's how a hypothetical "Tasks" module would integrate with Structure end-to-end:

<Tabs>
  <TabItem label="Frontend">

```
src/features/tasks/
├── index.ts                                    # Side-effect imports first
├── components/
│   ├── TasksTab.tsx                            # Tab content for node detail pages
│   ├── TaskCountBadge.tsx                      # Badge on node cards
│   └── TaskSummaryWidget.tsx                   # Widget for Overview tab
├── registrations/
│   ├── structure-tabs.registration.ts          # Register TasksTab
│   ├── structure-widgets.registration.ts       # Register TaskSummaryWidget
│   └── structure-cards.registration.ts         # Register TaskCountBadge
└── ...
```

**index.ts:**
```typescript
// Side-effect imports (registrations) FIRST
import './registrations/structure-tabs.registration';
import './registrations/structure-widgets.registration';
import './registrations/structure-cards.registration';

// Then public exports
export { taskRoutes } from './routes.config';
```

  </TabItem>
  <TabItem label="Backend">

```
src/features/tasks/
├── index.ts
├── tasks.routes.ts
├── tasks.service.ts
├── tasks.types.ts
├── tasks.init.ts                               # Register task-board node type
├── route.registration.ts
├── service.registration.ts
├── filter.registration.ts                      # Optional: transform Structure data
└── action.registration.ts                      # React to Structure events
```

**action.registration.ts:**
```typescript
import { actionRegistry } from '../../config/action.registry.js';
import { tasksService } from './tasks.service.js';

// Clean up when nodes are deleted
actionRegistry.addActionAsync(
  'structure.node.deleted',
  'tasks-cleanup',
  async (context) => {
    await tasksService.archiveTasksForNode(context.nodeId, context.userId);
  },
  20
);
```

  </TabItem>
</Tabs>

---

## Admin Control of Module Integrations

Admins can control module-provided content per node type via the **Templates > Module Integrations** tab in the admin page. This means your module's tabs, widgets, and card extensions can be:

- **Enabled/disabled** per node type
- **Renamed** (tabs only) — admins can override the label you provide
- **Reordered** — admins can change the display order
- **Slot reassigned** (card extensions only) — admins can move an extension between card positions

Your module doesn't need to do anything special to support this. The registries automatically check the `integrations` config on each node type before returning results. If an admin disables your tab for a particular node type, `getTabsForNodeType()` simply won't include it.

<Aside type="tip">
Module integrations are discovered at render time from the registries. As modules are installed or removed, the admin UI updates automatically to show available integrations.
</Aside>

---

## Integration Checklist

Use this checklist when building a module that integrates with Structure:

- [ ] **Dependency declared** — `dependencies: ['structure']` in `module.ts`
- [ ] **Frontend registrations** — Tabs, widgets, and/or card extensions registered via side-effect imports
- [ ] **Backend service access** — Use `serviceRegistry.get('structure')`, never direct imports
- [ ] **Event hooks** — Action registrations for cleanup on node delete, setup on node create
- [ ] **Schema isolation** — Plain `nodeId` string field with `@@index`, no `@relation`
- [ ] **Node types** — If registering types, set `moduleId` to your module ID
- [ ] **Order values** — Tabs/widgets use order 30+ (after Structure's built-in items)

---

## Next Steps

- [Registries](/modules/structure/registries/) — Full registry API reference
- [Components & Hooks](/modules/structure/components/) — Frontend component and hook reference
- [Database & API](/modules/structure/database/) — Schema and endpoint reference
- [Node Types](/modules/structure/node-types/) — Creating and configuring node types
