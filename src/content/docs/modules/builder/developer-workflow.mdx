---
title: Developer Workflow
description: How to develop, test, version, and maintain the Block Builder module
sidebar:
  order: 4
---

import { Aside, Tabs, TabItem } from '@astrojs/starlight/components';

This page covers the full developer workflow for working on the Block Builder module — from local setup to testing, versioning, and documentation.

---

## Setup

### Clone and Install

```bash
git clone <builder-repo-url>
cd builder
npm install
```

### Build

```bash
npm run build     # One-time build
npm run dev       # Watch mode (rebuilds on file changes)
```

### Link for Local Testing

```bash
npm link          # Makes the 'builder' command available globally
```

---

## Development Loop

The standard workflow when making changes:

```
Edit templates → Build → Test in app → Version bump → Commit → Push
```

### 1. Edit Templates

All your work happens in these locations:

| Location | What You Edit |
|----------|--------------|
| `src/templates/frontend/` | Frontend component, hook, and service templates |
| `src/templates/backend/` | Backend route, service, and registration templates |
| `src/templates/schema.ts` | Prisma schema (database tables) |
| `src/module.ts` | Module configuration (routes, dependencies, features list) |

<Aside type="caution">
Never edit files in `src/scaffold/` or `src/cli.ts`. These are shared infrastructure — report bugs upstream to the module starter template.
</Aside>

### 2. Build

```bash
npm run build
```

This compiles TypeScript to the `dist/` folder. Template string constants are bundled as-is — they're not transpiled, just included in the build output.

### 3. Test in a Starter App

In a separate terminal, navigate to a starter template app:

```bash
# Fresh install
npx builder init

# Update existing installation (after template changes)
npx builder update

# Preview what would change without modifying files
npx builder update --dry-run

# Force overwrite all files
npx builder init --force

# Check module metadata
npx builder info
```

<Aside type="tip">
Use `npx builder update --dry-run` before applying changes to see exactly which files would be modified. This is especially useful when testing schema changes.
</Aside>

### 4. Verify in the App

Start the test app and check:

- Frontend components render correctly
- Backend routes respond as expected
- Database tables are created properly
- Registry registrations appear in the right places
- No TypeScript errors in the generated code

---

## Version Management

### When to Bump

Bump the version after **any** change to:

| Path | Bump Required? |
|------|:-:|
| `src/templates/**/*.ts` | Yes |
| `src/module.ts` | Yes |
| `CLAUDE.md`, `README.md` | No |
| `docs/` | No |

### How to Bump

<Tabs>
  <TabItem label="Patch (Bug Fix)">
    ```bash
    npm run version:patch
    ```
    Use for: bug fixes, typos, minor adjustments. No changelog entry required.
  </TabItem>
  <TabItem label="Minor (New Feature)">
    ```bash
    npm run version:minor
    ```
    Use for: new features, enhancements. Add a changelog entry.
  </TabItem>
  <TabItem label="Major (Breaking)">
    ```bash
    npm run version:major
    ```
    Use for: breaking changes (renamed exports, removed features, schema changes). Add a changelog entry.
  </TabItem>
</Tabs>

Each version command automatically:
1. Updates the version in `package.json`
2. Updates the version in `src/module.ts`
3. Creates a git commit with the version bump message

### Tagged Releases

For a formal release (creates a git tag):

```bash
npm run release:patch    # or release:minor, release:major
git push --tags
```

### Why Versioning Matters

- **Version headers**: Generated files include a version header so apps know which version produced them
- **Update detection**: `npx builder update` compares installed version vs. available version
- **Hash comparison**: Individual file hashes determine which files need updating
- **Changelog tracking**: Users can see what changed between versions

---

## Scaffold Updates

The module starter template occasionally receives improvements (new CLI features, bug fixes). Pull these into your module:

### Check for Updates

```bash
npm run scaffold:check
```

This previews what would change without modifying any files.

### Apply Updates

```bash
npm run scaffold:update
```

This merges upstream scaffold improvements into your repo.

**What gets updated:**
- `src/scaffold/` files
- `src/cli.ts`
- Build scripts and configuration
- CLAUDE.md scaffold sections (between `SCAFFOLD:START` / `SCAFFOLD:END` markers)

**What does NOT get updated:**
- `src/templates/` (your templates)
- `src/module.ts` (your module config)
- Any customisations you've made outside scaffold sections

### Handling Merge Conflicts

If a scaffold update conflicts with your changes, Git will flag the conflicts. Resolve them manually, then commit:

```bash
# After resolving conflicts
git add .
git commit -m "chore: resolve scaffold update conflicts"
```

---

## Common Development Scenarios

### Adding a New Frontend Page

1. Create the page template in `src/templates/frontend/pages.ts`:
   ```typescript
   export const MY_NEW_PAGE = `// ========================================================================
   // FILE: frontend/src/features/builder/pages/MyNewPage.tsx
   // PURPOSE: Description of the page
   // ========================================================================

   // ... component code ...
   `;
   ```

2. Export it from `src/templates/frontend/index.ts`

3. Register it in `src/module.ts` under `frontend.templates`:
   ```typescript
   'pages/MyNewPage.tsx': frontend.MY_NEW_PAGE,
   ```

4. Add a route in the `frontend.routes.protectedRoutes` array

5. If it needs navigation, add an entry in the navigation registration template

### Adding a New Backend Endpoint

1. Add the route handler in `src/templates/backend/routes.ts` (inside `ROUTES_TEMPLATE`)

2. Add the service method in `src/templates/backend/services.ts` (inside `SERVICE_TEMPLATE`)

3. If you need new types, add them to `TYPES_TEMPLATE` in `routes.ts`

4. Update the frontend service in `src/templates/frontend/services.ts` with the API client method

### Adding a New Database Table

1. Add the model to `src/templates/schema.ts`:
   ```typescript
   export const SCHEMA = `
   // ... existing models ...

   model my_new_table {
     id        String   @id @default(cuid())
     userId    String
     // ... fields ...
     createdAt DateTime @default(now())
     updatedAt DateTime @updatedAt

     @@index([userId])
   }
   `;
   ```

2. Add the model name to `schema.modelNames` in `src/module.ts`

3. Remember: module schemas must be **self-contained** — use plain foreign key fields with `@@index`, never `@relation` directives

### Adding a New Registry Registration

1. Create the registration template (e.g. in `registrations.ts`)
2. Export it from the barrel file
3. Add it to `frontend.templates` in `src/module.ts`
4. Add it to `frontend.registrations` array for scaffold tracking
5. Import it as a side-effect in the index template:
   ```typescript
   import './registrations/my-new.registration.js';
   ```

### Adding a New Environment Variable

1. Document it in the configuration docs
2. If needed at init time, add a prompt to `moduleDefinition.prompts`
3. The scaffold handles `.env.example` updates automatically during init

### Adding a Prompt Variable

```typescript
// In src/module.ts
prompts: [
  {
    name: 'myVariable',
    message: 'Enter the value:',
    default: 'default-value',
  },
],
```

The value is then available in templates as `{{myVariable}}` with fallback syntax `{{myVariable|default}}`.

### Adding Lifecycle Hooks

```typescript
// In src/module.ts
backend: {
  // ...
  hasInit: true,  // Enables initBuilderModule() call on startup
},
```

Lifecycle hooks (`onInstall`, `onUpdate`, `onUninstall`) can be defined in `src/module.ts` and run during the respective CLI operations.

---

## Debugging and Troubleshooting

### Inspecting Generated Output

After running `npx builder init` or `update` in a test app, check the generated files:

```bash
# Frontend files
ls frontend/src/features/builder/

# Backend files
ls backend/src/features/builder/

# Schema additions
cat backend/prisma/schema.prisma | grep -A 20 "model block"
```

### Common Template Mistakes

| Symptom | Cause | Fix |
|---------|-------|-----|
| `my-feature` literal in output | Forgot to use placeholder pattern | Use `my-feature`, `MyFeature`, `myFeature` etc. |
| Import error in backend | Missing `.js` extension | Add `.js` to all relative imports in backend templates |
| Missing file header | New template file | Add the standard `// ========================================================================` header |
| Template not generated | Not registered in `module.ts` | Add to `frontend.templates` or `backend.templates` |

### Build Errors

| Error | Cause | Fix |
|-------|-------|-----|
| `Cannot find module` | Missing export in barrel file | Add export to `frontend/index.ts` or `backend/index.ts` |
| Template literal syntax error | Unescaped backtick in template | Use `\\\`` to escape backticks inside template strings |
| Type error in template | TypeScript in template string isn't validated | Template strings are just strings — check syntax manually |

### Update Not Detecting Changes

If `npx builder update` says "no changes" when you know you changed templates:

1. Did you bump the version? (`npm run version:patch`)
2. Did you rebuild? (`npm run build`)
3. Did you re-link? (`npm link`)

The update system compares file content hashes — if the version is the same, it may skip comparison.

### Backend Import Extensions

All relative imports in backend templates **must** use `.js` extensions:

```typescript
// ✅ Correct
import { builderService } from './builder.service.js';
import { prisma } from '../../lib/prisma.js';

// ❌ Wrong — will fail at runtime
import { builderService } from './builder.service';
```

---

## Documentation Workflow

The `docs/` directory is a git submodule pointing to the shared documentation site.

### Making Documentation Changes

```bash
# 1. Edit docs
cd docs
# Edit .mdx files under src/content/docs/modules/builder/

# 2. Commit and push the docs submodule
git add .
git commit -m "Docs: description of changes"
git push

# 3. Back in the main repo, update the submodule reference
cd ..
git add docs
git commit -m "docs: update docs submodule"
```

### Documentation Deployment

Documentation deploys automatically via GitHub Actions when the docs submodule is pushed. Changes appear on `saas.uniqueicon.com.au` within minutes.

### Sidebar Configuration

The docs sidebar is configured in `docs/astro.config.mjs`. When adding new pages, add corresponding entries to the sidebar array under the Builder section.
