---
title: Scaffold Architecture
description: How the scaffold infrastructure works — installation pipeline, template processing, and auto-registration
---

import { Steps, Aside } from '@astrojs/starlight/components';

The scaffold is the shared infrastructure that powers every module. It handles installing templates into apps, tracking what was installed, detecting changes, and updating modules. You don't edit these files — but understanding how they work helps you build better modules and maintain the module starter.

---

## What Is the Scaffold?

The scaffold is the `src/scaffold/` directory in the module starter. When you clone the module starter to create a new module, you get this infrastructure automatically. It provides the CLI commands (`init`, `update`, `uninstall`, etc.) that users run to manage your module in their app.

```
src/scaffold/
├── init.ts              # Installation pipeline
├── update.ts            # Hash-based change detection and updates
├── uninstall.ts         # Manifest-based cleanup
├── enable.ts            # Re-enable a disabled module
├── disable.ts           # Disable without removing
├── update-schema.ts     # Prisma schema sync
├── lifecycle-utils.ts   # Lifecycle hook infrastructure
├── types.ts             # TypeScript interfaces
├── utils.ts             # Shared utilities
└── index.ts             # Public exports
```

<Aside type="caution">
These files are marked "DO NOT EDIT". Changes to the scaffold propagate to all modules via `scaffold:update`. If you find a bug, report it upstream to the module starter repository.
</Aside>

---

## Installation Pipeline

When a user runs `npx my-module init`, the scaffold runs a 10-step installation pipeline:

<Steps>
1. **Check required modules** — If your module declares `requiredModules`, verifies they're installed by checking for their feature directories

2. **Interactive setup** — Runs module-specific prompts (from `module.ts`), detects frontend/backend paths, asks about auto-registration, shadcn components, and dependency installation

3. **Copy database schema** — Detects Prisma structure (multi-file or single-file), processes template placeholders, appends models. For multi-file setups, creates `prisma/my-module.prisma`. For single-file, appends to `schema.prisma`

4. **Generate frontend files** — Creates directory structure, processes all frontend templates (replacing placeholders), adds version headers, writes files. Processes `templates`, `indexFiles`, and `registrations` from your module config

5. **Generate backend files** — Same process for backend templates. Uses your `indexTemplate` if provided, otherwise generates one with side-effect registration imports

6. **Auto-register** — Wires the module into the app (see [Auto-Registration](#auto-registration) below)

7. **Environment variables** — Collects values for env variables (supporting `secret` input and `when` conditionals), writes to frontend `.env` (with `VITE_` prefix) and backend `.env` separately

8. **Install UI components** — Runs `npx shadcn@latest add` for each component. Also handles third-party UI libraries (`uiLibraries` config) with their registries

9. **Install dependencies** — Runs `npm install` in frontend and backend directories. Handles provider-specific dependencies based on prompt answers

10. **Save manifest and run lifecycle hooks** — Saves `.module-manifests.json` tracking all installed files and registrations, then runs `onInstall` and `onActivate` lifecycle hooks
</Steps>

---

## Template Processing

The `processTemplate()` function handles all placeholder replacement. Every template string passes through this before being written to disk.

### Name Placeholders

| Pattern | Replaced With | Example (module id: `ai-chat`) |
|---------|--------------|-------------------------------|
| `my-feature` | Module ID (kebab-case) | `ai-chat` |
| `myFeature` | camelCase | `aiChat` |
| `MyFeature` | PascalCase | `AiChat` |
| `my_feature` | snake_case | `ai_chat` |

### Conditional Blocks

Templates support Handlebars-style `{{#if}}` / `{{else}}` / `{{/if}}` conditionals, evaluated against prompt answers:

```typescript
// Simple truthy check
{{#if includeApi}}
import { api } from '@/lib/api';
{{/if}}

// Equality check with else
{{#if provider === 'stripe'}}
import Stripe from 'stripe';
const client = new Stripe(process.env.STRIPE_SECRET_KEY);
{{else}}
import { Paddle } from '@paddle/paddle-node-sdk';
const client = new Paddle(process.env.PADDLE_API_KEY);
{{/if}}

// Inequality check
{{#if mode !== 'manual'}}
startAutoProcess();
{{/if}}
```

**Truthiness rules:**
- Truthy: `true`, non-empty strings, non-zero numbers
- Falsy: `false`, `null`, `undefined`, `''`, `0`, variable not provided
- If no variables are passed to `processTemplate()`, conditional blocks are left unchanged

<Aside type="tip">
Conditionals are evaluated **before** variable substitution. This means you can use `{{variable}}` placeholders inside conditional blocks and they'll be substituted after the block is resolved.
</Aside>

### Variable Substitution

Variables from prompt answers use double-brace syntax with optional defaults:

```typescript
const provider = '{{provider}}';
const timeout = {{timeout|5000}};       // Default: 5000
const model = '{{model|gpt-4}}';        // Default: 'gpt-4'
```

### Processing Order

The `processTemplate()` function runs three steps in order:

1. **Name placeholders** — `my-feature` → `ai-chat`, etc.
2. **Conditional blocks** — `{{#if}}` / `{{else}}` / `{{/if}}` evaluated and resolved
3. **Variable substitution** — `{{variable}}` and `{{variable|default}}` replaced

### File Path Processing

File paths in `templates` keys are also processed:

```typescript
templates: {
  'my-feature.routes.ts': backend.ROUTES_TEMPLATE,
}
// Becomes: ai-chat.routes.ts (for module id "ai-chat")
```

---

## Auto-Registration

The scaffold automatically wires modules into three integration points during installation.

### Frontend Routes (`routes.tsx`)

```typescript
// Before installation:
...userRoutes,
...adminRoutes,
// ...featureRoutes,

// After installation:
...userRoutes,
...adminRoutes,

// --- AI Chat Module routes ---
...aiChatRoutes,
// ...featureRoutes,
```

The scaffold finds the last spread route pattern and inserts after it. The `// ...featureRoutes` comment serves as a fallback insertion point.

### Frontend Navigation

If your module has a `navigation.registration.ts` template, the scaffold detects it uses the **registry pattern** and skips any config file editing. The registration runs automatically as a side-effect import in your module's barrel file.

### Backend Routes (`app.ts`)

```typescript
// Feature registrations
import './features/user/index.js';
import './features/admin/index.js';
import './features/ai-chat/index.js';    // ← Added by scaffold
```

The scaffold finds the feature registrations section or the last feature import and appends yours.

---

## Enable / Disable

Modules can be temporarily disabled without removing files:

```bash
npx my-module disable    # Runs onDeactivate hook, marks disabled
npx my-module enable     # Runs onActivate hook, marks enabled
```

Module state is tracked in `.module-state.json`. The scaffold sets an `enabled` boolean flag — it does **not** comment out imports or modify generated code. What "disabled" means for your module is defined by your `onDeactivate` and `onActivate` lifecycle hooks (pausing jobs, unregistering webhooks, hiding UI, etc.).

For lifecycle hook details, see [Lifecycle Hooks](/module-starter/lifecycle-hooks/).

---

## CLI Commands Reference

| Command | Purpose | Key Options |
|---------|---------|-------------|
| `init` | Install module into app | `--force` (overwrite), `--no-interactive` |
| `update` | Update templates to latest | `--dry-run`, `--force` |
| `update-schema` | Sync Prisma schema only | `--force` |
| `migrate` | Add version headers to old files | `--dry-run` |
| `uninstall` | Remove module completely | `--force`, `--keep-data`, `--export <path>` |
| `disable` | Disable without removing | `--force` |
| `enable` | Re-enable disabled module | `--force` |
| `info` | Show module information | — |

---

## Next Steps

- [Starter Integration](/module-starter/starter-integration/) — How the scaffold connects to the starter template
- [Versioning & Updates](/module-starter/versioning/) — Version headers, update mechanism, and manifest system
- [Lifecycle Hooks](/module-starter/lifecycle-hooks/) — Module lifecycle hooks and the full context API
- [Building Your Module](/module-starter/building-modules/) — Customise templates and configuration
- [Code Templates](/module-starter/templates/) — Copy-paste template reference
