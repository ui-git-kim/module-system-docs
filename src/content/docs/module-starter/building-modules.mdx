---
title: Building Modules
description: How to author a module after cloning the module starter — configuration, templates, testing, and publishing
---

import { Steps, Tabs, TabItem, Aside, FileTree } from '@astrojs/starlight/components';

This guide covers everything you need to build a module **after** cloning the module starter. For the clone process itself, see [Create Script](/module-starter/create-script/).

<Aside type="note">
**Key implications of the module development workflow:**
- Templates use `@/` imports that resolve **in the starter template**, not in this repo
- You do not have access to starter template code during development
- Shared UI components live in the starter at `@/components/settings-blocks` and `@/components/page-blocks`
- Test by building, linking, and running `init` in a real starter project
</Aside>

---

## What to Edit

The module starter separates your code from shared infrastructure. Know which files are yours.

### Your Code (Edit These)

| File | Purpose |
|------|---------|
| `src/module.ts` | Module identity, configuration, templates, prompts |
| `src/templates/**/*.ts` | Template string constants that generate code in apps |
| `package.json` | Module name, version, dependencies, bin command |
| `CLAUDE.md` | AI assistant instructions for your module |

### Shared Infrastructure (Do NOT Edit)

| File | Purpose |
|------|---------|
| `src/cli.ts` | CLI entry point and command routing |
| `src/scaffold/**/*.ts` | Installation, update, uninstall, enable/disable logic |
| `scripts/*` | Version bump and build scripts |
| `VERSION` | Scaffold infrastructure version (auto-managed) |

<Aside type="caution">
Scaffold files are maintained upstream in the module starter repo. Editing them in your cloned module will cause merge conflicts when you run `scaffold:update`. If you find a bug, report it upstream.
</Aside>

---

## Module Configuration

The `src/module.ts` file defines everything about your module. Here is a billing module example showing all key configuration options:

```typescript
import type { ModuleDefinition } from './scaffold/index.js';
import { SCHEMA } from './templates/schema.js';
import * as frontend from './templates/frontend/index.js';
import * as backend from './templates/backend/index.js';

export const moduleDefinition: ModuleDefinition = {
  id: 'billing',
  name: 'Billing',
  description: 'Billing and subscription management',
  version: '1.0.0',
  schema: {
    content: SCHEMA,
    modelNames: ['billing_subscription', 'billing_invoice'],
  },
  frontend: {
    directories: ['pages', 'components', 'hooks', 'services', 'types', 'registrations'],
    templates: {
      'routes.config.tsx': frontend.ROUTES_CONFIG,
      'navigation.registration.ts': frontend.NAVIGATION_REGISTRATION,
      'pages/BillingPage.tsx': frontend.PAGE_TEMPLATE,
      'services/billing.service.ts': frontend.SERVICE_TEMPLATE,
      'types/index.ts': frontend.TYPES_TEMPLATE,
    },
    indexFiles: [
      { path: 'index.ts', content: frontend.INDEX_TEMPLATE },
    ],
    shadcnComponents: ['card', 'button', 'badge'],
    dependencies: [],
    navigation: {
      sidebarItems: [
        { title: 'Billing', url: '/billing', icon: 'CreditCard' },
      ],
    },
    routes: {
      protectedRoutes: [
        { path: 'billing', element: 'BillingPage' },
      ],
      insertAfter: 'auto',
    },
    registrations: [
      {
        type: 'settingsPage',
        path: 'registrations/settings-page.registration.ts',
        content: frontend.SETTINGS_PAGE_REGISTRATION,
      },
    ],
  },
  backend: {
    templates: {
      'billing.routes.ts': backend.ROUTES_TEMPLATE,
      'billing.service.ts': backend.SERVICE_TEMPLATE,
      'billing.types.ts': backend.TYPES_TEMPLATE,
      'route.registration.ts': backend.ROUTE_REGISTRATION,
      'service.registration.ts': backend.SERVICE_REGISTRATION,
    },
    indexTemplate: backend.INDEX_TEMPLATE,
    dependencies: ['stripe'],
    apiPath: '/api/v1/billing',
    hasInit: false,
  },
  prompts: [
    {
      id: 'provider',
      type: 'select',
      question: 'Which payment provider?',
      options: [
        { value: 'stripe', label: 'Stripe' },
        { value: 'paddle', label: 'Paddle' },
      ],
      default: 'stripe',
    },
  ],
  features: [
    'Subscription management',
    'Invoice generation',
    'Payment processing',
  ],
  envVariables: {
    backend: [
      { name: 'STRIPE_SECRET_KEY', description: 'Stripe secret API key', required: true, secret: true },
    ],
    frontend: [
      { name: 'BILLING_PUBLIC_KEY', description: 'Stripe publishable key' },
    ],
  },
};
```

<Aside type="tip">
The default `src/module.ts` in the module starter includes all options with comments. Start by editing the identity fields, then customise the templates and registrations for your module.
</Aside>

### Configuration Reference

| Field | Required | Purpose |
|-------|----------|---------|
| `id` | Yes | Kebab-case identifier used in file paths and CLI |
| `name` | Yes | Human-readable name for CLI output |
| `description` | Yes | Short description shown in module info |
| `version` | Yes | Semver version stamped into generated file headers |
| `schema` | No | Prisma models and model name list |
| `schema.content` | Yes* | Template string containing Prisma model definitions |
| `schema.modelNames` | Yes* | Array of model names for tracking and uninstall |
| `frontend` | Yes | Frontend configuration block |
| `frontend.directories` | Yes | Folder structure to create in the feature directory |
| `frontend.templates` | Yes | `Record<string, string>` mapping relative paths to template content |
| `frontend.indexFiles` | Yes | Barrel files with side-effect registration imports |
| `frontend.shadcnComponents` | Yes | UI components to install (can be empty array) |
| `frontend.dependencies` | Yes | npm packages for the frontend (can be empty array) |
| `frontend.navigation` | Yes | Navigation metadata (actual config lives in template) |
| `frontend.routes` | Yes | Route metadata (actual routes live in template) |
| `frontend.registrations` | No | Array of registry registration files to generate |
| `frontend.uiLibraries` | No | Third-party UI libraries installed via shadcn registry — see `UILibraryConfig` in types |
| `backend` | No | Delete entirely for frontend-only modules |
| `backend.templates` | Yes* | `Record<string, string>` mapping filenames to template content |
| `backend.indexTemplate` | No | Custom barrel file (recommended over auto-generation) |
| `backend.configTemplate` | No | Config/initialisation file template — creates `[module-id].config.ts` |
| `backend.dependencies` | Yes* | npm packages for the backend (can be empty array) |
| `backend.providerDependencies` | No | Conditional npm packages based on prompt answers (e.g., install `stripe` only if provider is `'stripe'`) |
| `backend.apiPath` | Yes* | API route path (documentation — actual registration is in `route.registration.ts`) |
| `backend.hasInit` | Yes* | Whether the module has an init function |
| `backend.requireAuth` | No | Whether routes require authentication (default: `true`) |
| `prompts` | No | Questions asked during `npx my-module init` — answers available as `{{variable}}` in templates |
| `features` | Yes | Feature list shown in post-install summary |
| `envVariables` | No | Split into `{ frontend: [], backend: [] }` — see [Environment Variables](#environment-variables) |
| `requiredModules` | No | Module IDs that must be installed first — see [Module Dependencies](#module-dependencies) |
| `lifecycle` | No | Hooks for install, update, activate, deactivate, uninstall — see [Lifecycle Hooks](/module-starter/lifecycle-hooks/) |

Fields marked **Yes*** are required only when their parent block is present.

---

## Template Placeholders

Templates use placeholder patterns that get replaced during installation. This is how a single set of template files produces correctly named output for any module.

### Name Patterns

Every occurrence of these patterns is replaced with the corresponding case variant of your module ID.

| Pattern | Case | Example (id: `ai-chat`) |
|---------|------|------------------------|
| `My Feature` | Title Case (space-separated) | `Ai Chat` |
| `my feature` | lowercase (space-separated) | `ai chat` |
| `my-feature` | kebab-case | `ai-chat` |
| `myFeature` | camelCase | `aiChat` |
| `MyFeature` | PascalCase | `AiChat` |
| `my_feature` | snake_case | `ai_chat` |

Use these patterns in file content, file paths, function names, component names, and Prisma model names. The scaffold replaces them everywhere.

- **`My Feature`** and **`my feature`** — For human-readable text: page titles, labels, descriptions, breadcrumbs, comments
- **`my-feature`** — For file names, URL paths, CSS classes, HTML attributes
- **`myFeature`** and **`MyFeature`** — For JavaScript/TypeScript identifiers (variables, functions, components)
- **`my_feature`** — For database models, snake_case identifiers

**Example transformation (code):**

```typescript
// Template (before)
export const myFeatureRoutes: RouteObject[] = [
  { path: 'my-feature', element: <MyFeaturePage /> }
];

// Generated (after, with moduleId = 'ai-chat')
export const aiChatRoutes: RouteObject[] = [
  { path: 'ai-chat', element: <AiChatPage /> }
];

// Template (before)
<h1 className="text-2xl font-semibold">My Feature</h1>
<p>Welcome to My Feature. Start building something awesome!</p>

// Generated (after, with moduleId = 'ai-chat')
<h1 className="text-2xl font-semibold">Ai Chat</h1>
<p>Welcome to Ai Chat. Start building something awesome!</p>
```

### Variable Substitution

Variables from prompt answers use double-brace syntax. Add a pipe and default value for fallbacks.

```typescript
// Simple variable (replaced with prompt answer)
const provider = '{{provider}}';

// Variable with default fallback
const timeout = {{timeout|5000}};
const model = '{{model|gpt-4}}';
const region = '{{region|ap-southeast-2}}';
```

If the user does not answer the prompt (or the variable is not provided), the default value is used. Without a default, the placeholder is left as-is.

### Conditional Blocks

Templates support `{{#if}}` / `{{else}}` / `{{/if}}` blocks evaluated against prompt answers.

**Simple truthy check:**

```typescript
{{#if includeApi}}
import { api } from '@/lib/api';
{{/if}}
```

**Equality with else:**

```typescript
{{#if provider === 'stripe'}}
import Stripe from 'stripe';
const client = new Stripe(process.env.STRIPE_SECRET_KEY);
{{else}}
import { Paddle } from '@paddle/paddle-node-sdk';
const client = new Paddle(process.env.PADDLE_API_KEY);
{{/if}}
```

**Inequality check:**

```typescript
{{#if mode !== 'manual'}}
startAutoProcess();
{{/if}}
```

**Nesting:**

```typescript
{{#if includeApi}}
{{#if provider === 'stripe'}}
import Stripe from 'stripe';
{{/if}}
{{/if}}
```

**Truthiness rules:**
- Truthy: `true`, non-empty strings, non-zero numbers
- Falsy: `false`, `null`, `undefined`, `''`, `0`, variable not provided

Conditionals are evaluated **before** variable substitution. You can use `{{variable}}` placeholders inside conditional blocks and they will be substituted after the block is resolved.

See [Scaffold Architecture -- Conditional Blocks](/module-starter/scaffold/#conditional-blocks) for the full processing order and advanced usage.

---

## Adding Custom Template Files

The module starter ships with templates for the most common patterns. Larger modules often need more -- hooks, utilities, dialogs, context providers, or anything else your feature requires.

<Steps>
1. **Create the template file** in the appropriate directory.

   ```typescript
   // src/templates/frontend/hooks.ts
   export const USE_MY_FEATURE_HOOK = `// ========================================================================
   // FILE: frontend/src/features/my-feature/hooks/useMyFeature.ts
   // PURPOSE: Core hook for my-feature state and logic
   // ========================================================================

   import { useState, useCallback } from 'react';

   export function useMyFeature() {
     const [items, setItems] = useState<MyFeatureItem[]>([]);

     const refresh = useCallback(async () => {
       // Fetch items from API
     }, []);

     return { items, refresh };
   }
   `;

   export const USE_MY_FEATURE_CONFIG_HOOK = `// ========================================================================
   // FILE: frontend/src/features/my-feature/hooks/useMyFeatureConfig.ts
   // PURPOSE: Configuration hook for my-feature settings
   // ========================================================================

   import { useQuery } from '@tanstack/react-query';

   export function useMyFeatureConfig() {
     return useQuery({
       queryKey: ['my-feature-config'],
       queryFn: () => fetch('/api/v1/my-feature/config').then(r => r.json()),
     });
   }
   `;
   ```

2. **Export from the index file.** Add your new file to `src/templates/frontend/index.ts`:

   ```typescript
   // Hooks
   export { USE_MY_FEATURE_HOOK, USE_MY_FEATURE_CONFIG_HOOK } from './hooks.js';
   ```

3. **Reference in module.ts.** Add the templates to your frontend configuration:

   ```typescript
   frontend: {
     directories: ['pages', 'components', 'hooks', 'services', 'types', 'registrations'],
     templates: {
       // ... existing templates
       'hooks/useMyFeature.ts': frontend.USE_MY_FEATURE_HOOK,
       'hooks/useMyFeatureConfig.ts': frontend.USE_MY_FEATURE_CONFIG_HOOK,
     },
   },
   ```
</Steps>

### Guidelines

- **One file per category.** Group related templates together (all hooks in `hooks.ts`, all dialogs in `dialogs.ts`). Split into separate files if a single file gets too large.
- **Use the file header pattern.** Every template should start with the `// FILE:` and `// PURPOSE:` comment block. The scaffold adds a version header above this during installation.
- **Use placeholders.** Templates should use My Feature and my feature for human-readable text, my-feature, MyFeature, myFeature, my_feature for code identifiers, and `{{variable}}` for prompt-based values
- **Add directories.** If your templates create files in new subdirectories, add those to `frontend.directories` (e.g., `'hooks'`, `'dialogs'`, `'utils'`).
- **Frontend uses `@/` imports.** Frontend templates use the `@/` alias which resolves in the starter template (e.g., `import { Button } from '@/components/ui/button'`).
- **Backend uses `.js` imports.** Any relative import in a backend template must use the `.js` extension for ESM compatibility (e.g., `import { myFeatureService } from './my-feature.service.js'`).
- **Update shadcnComponents.** If your new templates use shadcn imports, add those components to the `shadcnComponents` array in `module.ts`.

<Aside type="tip">
Template files are just TypeScript files that export string constants. There is no limit to how many you can create. The `index.ts` barrel file re-exports everything so `module.ts` can import with `import * as frontend from './templates/frontend/index.js'`.
</Aside>

---

## Environment Variables

Modules can collect environment variables during installation and write them to `.env` files. Define them in the `envVariables` block of `module.ts`:

```typescript
envVariables: {
  frontend: [
    {
      name: 'BILLING_PUBLIC_KEY',
      description: 'Stripe publishable key',
      default: 'pk_test_...',
      required: false,
    },
  ],
  backend: [
    {
      name: 'STRIPE_SECRET_KEY',
      description: 'Stripe Secret Key (from Stripe Dashboard > API Keys)',
      required: true,
      secret: true,
    },
    {
      name: 'STRIPE_WEBHOOK_SECRET',
      description: 'Stripe Webhook Secret (starts with whsec_)',
      required: true,
      secret: true,
    },
    {
      name: 'AI_PROVIDER_KEY',
      description: 'AI Provider API Key',
      required: true,
      secret: true,
      when: (answers) => answers.provider === 'anthropic',
    },
  ],
},
```

### EnvVariable Properties

| Property | Type | Description |
|----------|------|-------------|
| `name` | `string` | Variable name — frontend vars are automatically prefixed with `VITE_` |
| `description` | `string` | Shown to user during collection |
| `required` | `boolean` | Warn if not provided (default: `false`) |
| `default` | `string` | Default value pre-filled in prompt |
| `secret` | `boolean` | Mask input display (default: `false`) |
| `when` | `(answers) => boolean` | Only collect when condition is true (receives prompt answers) |

<Aside type="tip">
Frontend environment variables are automatically prefixed with `VITE_` by the scaffold. If you define `name: 'BILLING_PUBLIC_KEY'`, the actual variable written to `frontend/.env` will be `VITE_BILLING_PUBLIC_KEY`.
</Aside>

---

## Module Dependencies

Modules can declare dependencies on other modules using `requiredModules`:

```typescript
export const moduleDefinition: ModuleDefinition = {
  id: 'billing-reports',
  requiredModules: ['billing'],
  // ...
};
```

**Behaviour:**
- The init script checks if required feature folders exist in both `frontend/src/features/` and `backend/src/features/` before proceeding
- Fails gracefully with a clear message listing missing dependencies
- Modules should be self-contained at the database level — use `requiredModules` for **runtime** service dependencies, not database foreign keys

**Cross-module data access:** If your module needs data from another module, access it via that module's service at runtime. Do **not** create database foreign keys to other modules' tables:

```typescript
// ✅ Runtime service call — no database FK
import { billingService } from '@/features/billing';
const subscription = await billingService.getSubscription(userId);
```

---

## shadcn Component Management

The `shadcnComponents` array in `module.ts` must list every shadcn component your templates import. There is no automatic detection — you must keep this in sync manually.

**How to identify required components:**

1. Search your templates for `@/components/ui/` imports
2. Extract the component name (the folder after `ui/`)
3. Add it to the `shadcnComponents` array

**Common components by template type:**

| Template | Typically Uses |
|----------|---------------|
| Page (basic) | `card`, `button` |
| Preferences | `label`, `switch`, `select` |
| Dashboard Widget | `card` |
| Integration | `card`, `button`, `badge` |
| Forms | `input`, `label`, `button`, `select` |
| Dialogs | `dialog`, `button` |

---

## Starter Components

The starter template provides reusable components and hooks that your module templates can import. These are documented in the starter template feature pages — always check the docs for the current list.

### Settings Blocks

Import from `@/components/settings-blocks` (shared library for settings and admin pages):

| Component | Purpose |
|-----------|---------|
| `Row` | Two column: label left, action right |
| `Row3Col` | Three column: label, middle content, action |
| `RowStacked` | Content below label, action top right |
| `SectionHeader` | Section title with optional action |
| `Divider` | Dashed horizontal divider |
| `Note` | Info box for additional context |
| `DangerBox` | Red box for destructive actions |
| `PlanCard` | Marketing-style plan display |
| `ProviderCard` | Card for connected accounts/services |
| `Table` | Table for sessions, invoices, etc. |
| `ToggleSwitch` | Toggle control (compose with `Row`) |
| `Dropdown` | Select dropdown (compose with `Row3Col`) |
| `ToggleGroup` | Multiple toggles in a compact card |
| `TabBar` | Page-level tab navigation |
| `DisabledRow` | Greyed-out row with "Coming soon" badge |

### Page Blocks

Import from `@/components/page-blocks` (shared library for page-level structure):

| Component | Purpose |
|-----------|---------|
| `PageHeader` | Page title with icon, description, badge |
| `LoadingState` | Centred loading spinner |
| `ErrorAlert` | Error alert (renders null when no error) |
| `EmptyState` | Centred empty state with icon and action |

➡️ **[User Feature](/starter-template/user-feature/)** — Full settings-blocks reference with props and examples

### User Hooks

| Hook | Import | Purpose |
|------|--------|---------|
| `useSession` | `@/features/auth` | Current user and session data |
| `useUserProfile` | `@/features/user/hooks/useUserProfile` | Profile data, preferences, and update methods |

➡️ **[Auth Feature](/starter-template/auth-feature/)** — Session hook and auth components
➡️ **[User Feature](/starter-template/user-feature/)** — Profile hook and user components

### User Avatar

```typescript
import { UserAvatar } from '@/features/user/components/UserAvatar';

<UserAvatar />                    // Current user's avatar
<UserAvatar size="lg" />          // Size: 'sm' | 'md' | 'lg' | 'xl'
<UserAvatar imageUrl={url} />     // Override with custom image
```

<Aside type="tip">
Both settings and admin pages use the same shared component libraries (`settings-blocks` and `page-blocks`). Always check the [starter template feature docs](/starter-template/features/) for the latest available components.
</Aside>

---

## Testing Your Module

<Steps>
1. **Build the module.**

   ```bash
   npm run build
   ```

2. **Link locally.**

   ```bash
   npm link
   ```

3. **Install in a test app.** Open a separate terminal and navigate to a starter template clone.

   ```bash
   cd ../my-test-app
   npx my-billing-module init
   ```

4. **Verify the installation.**
   - Check `frontend/src/features/billing/` exists with all expected files
   - Check `backend/src/features/billing/` exists (if your module has a backend)
   - Run the app with `npm run dev`
   - Navigate to your module's page in the browser
   - Confirm navigation items, routes, and registrations are working
</Steps>

<Aside type="tip">
After making changes to your templates, run `npm run build` again and re-install in the test app with `npx my-billing-module init --force` to overwrite previous files.
</Aside>

---

## Publishing

### Version Bump

Before publishing, bump the version. This updates both `package.json` and `src/module.ts`, commits the change, and creates a git tag.

```bash
npm run release:patch    # Bug fixes (1.0.0 -> 1.0.1)
npm run release:minor    # New features (1.0.0 -> 1.1.0)
npm run release:major    # Breaking changes (1.0.0 -> 2.0.0)
```

**Why this matters.** Every generated file gets a version header like `// @generated-by: billing v1.0.1 | hash: abc123`. The `update` command uses this version to detect changes and determine whether lifecycle hooks should run. If you change templates without bumping, `npx my-module update` will not detect the changes.

### npm Publish

```bash
npm publish
```

Users can then install your module with:

```bash
npx my-billing-module init
```

---

## Module Types

Modules generally fall into one of these categories:

| Type | Description | Key Registries |
|------|-------------|----------------|
| **Standard Feature** | Has own pages, navigation, possibly dashboard widget and backend API | Navigation, Dashboard, Routes |
| **Settings Replacement** | Replaces a placeholder page (e.g., Billing). Uses `isReplacement: true` | Settings Pages, Routes |
| **Integration** | Adds to the Integrations page. Usually connects to an external service | Integrations, Preferences |
| **Profile Extension** | Adds fields to the Personal Information page. Stores data in `User.preferences` | Personal Info Fields |

Most modules are **Standard Feature** modules. Choose the type that best fits your module's purpose, then add additional registries as needed.

---

## Pre-Publish Checklist

Before publishing your module, verify:

- [ ] Updated `package.json` (name, description, bin command)
- [ ] Updated `module.ts` (id, name, description, version)
- [ ] Set `requiredModules` if depending on other modules
- [ ] Wrote Prisma schema (if needed) — self-contained, no `@relation`, no cross-module FKs
- [ ] Wrote frontend templates
- [ ] Wrote backend templates (if needed) — `.js` extensions on all relative imports
- [ ] **Updated `shadcnComponents` with every shadcn import from templates**
- [ ] Added registry registrations (navigation, dashboard, preferences, etc.)
- [ ] Updated `index.ts` barrel files to import registrations as side effects
- [ ] Tested with `npm run build && npm link`
- [ ] Tested `init` in a starter project — routes, pages, registrations all working
- [ ] Tested `uninstall` removes files and registrations cleanly
- [ ] Version bumped with `npm run release:patch/minor/major`

---

## Next Steps

- [Module Database](/module-starter/database/) -- Schema patterns, transactions, and self-contained design
- [Registry Guide](/module-starter/registry-guide/) -- How to register with the starter template's registries
- [File Reference](/module-starter/file-reference/) -- Detailed module file structure
- [Scaffold Architecture](/module-starter/scaffold/) -- How the scaffold infrastructure works
- [Code Templates](/module-starter/templates/) -- Copy-paste template reference
- [Lifecycle Hooks](/module-starter/lifecycle-hooks/) -- Filters, actions, and module lifecycle
