---
title: Building Modules
description: How to author a module after cloning the module starter â€” configuration, templates, testing, and publishing
---

import { Steps, Tabs, TabItem, Aside, FileTree } from '@astrojs/starlight/components';

This guide covers everything you need to build a module **after** cloning the module starter. For the clone process itself, see [Create Script](/module-starter/create-script/).

---

## What to Edit

The module starter separates your code from shared infrastructure. Know which files are yours.

### Your Code (Edit These)

| File | Purpose |
|------|---------|
| `src/module.ts` | Module identity, configuration, templates, prompts |
| `src/templates/**/*.ts` | Template string constants that generate code in apps |
| `package.json` | Module name, version, dependencies, bin command |
| `CLAUDE.md` | AI assistant instructions for your module |

### Shared Infrastructure (Do NOT Edit)

| File | Purpose |
|------|---------|
| `src/cli.ts` | CLI entry point and command routing |
| `src/scaffold/**/*.ts` | Installation, update, uninstall, enable/disable logic |
| `scripts/*` | Version bump and build scripts |
| `VERSION` | Scaffold infrastructure version (auto-managed) |

<Aside type="caution">
Scaffold files are maintained upstream in the module starter repo. Editing them in your cloned module will cause merge conflicts when you run `scaffold:update`. If you find a bug, report it upstream.
</Aside>

---

## Module Configuration

The `src/module.ts` file defines everything about your module. Here is a billing module example showing all key configuration options:

```typescript
import type { ModuleDefinition } from './scaffold/index.js';
import { SCHEMA } from './templates/schema.js';
import * as frontend from './templates/frontend/index.js';
import * as backend from './templates/backend/index.js';

export const moduleDefinition: ModuleDefinition = {
  id: 'billing',
  name: 'Billing',
  description: 'Billing and subscription management',
  version: '1.0.0',
  schema: {
    content: SCHEMA,
    modelNames: ['billing_subscription', 'billing_invoice'],
  },
  frontend: {
    directories: ['pages', 'components', 'hooks', 'services', 'types', 'registrations'],
    templates: {
      'routes.config.tsx': frontend.ROUTES_CONFIG,
      'navigation.registration.ts': frontend.NAVIGATION_REGISTRATION,
      'pages/BillingPage.tsx': frontend.PAGE_TEMPLATE,
      'services/billing.service.ts': frontend.SERVICE_TEMPLATE,
      'types/index.ts': frontend.TYPES_TEMPLATE,
    },
    indexFiles: [
      { path: 'index.ts', content: frontend.INDEX_TEMPLATE },
    ],
    shadcnComponents: ['card', 'button', 'badge'],
    dependencies: [],
    navigation: {
      sidebarItems: [
        { title: 'Billing', url: '/billing', icon: 'CreditCard' },
      ],
    },
    routes: {
      protectedRoutes: [
        { path: 'billing', element: 'BillingPage' },
      ],
      insertAfter: 'auto',
    },
    registrations: [
      {
        type: 'settingsPage',
        path: 'registrations/settings-page.registration.ts',
        content: frontend.SETTINGS_PAGE_REGISTRATION,
      },
    ],
  },
  backend: {
    templates: {
      'billing.routes.ts': backend.ROUTES_TEMPLATE,
      'billing.service.ts': backend.SERVICE_TEMPLATE,
      'billing.types.ts': backend.TYPES_TEMPLATE,
      'route.registration.ts': backend.ROUTE_REGISTRATION,
      'service.registration.ts': backend.SERVICE_REGISTRATION,
    },
    indexTemplate: backend.INDEX_TEMPLATE,
    dependencies: ['stripe'],
    apiPath: '/api/v1/billing',
    hasInit: false,
  },
  prompts: [
    {
      id: 'provider',
      type: 'select',
      question: 'Which payment provider?',
      options: [
        { value: 'stripe', label: 'Stripe' },
        { value: 'paddle', label: 'Paddle' },
      ],
      default: 'stripe',
    },
  ],
  features: [
    'Subscription management',
    'Invoice generation',
    'Payment processing',
  ],
  envVariables: {
    backend: [
      { name: 'STRIPE_SECRET_KEY', description: 'Stripe secret API key', required: true, secret: true },
    ],
    frontend: [
      { name: 'BILLING_PUBLIC_KEY', description: 'Stripe publishable key' },
    ],
  },
};
```

<Aside type="tip">
The default `src/module.ts` in the module starter includes all options with comments. Start by editing the identity fields, then customise the templates and registrations for your module.
</Aside>

### Configuration Reference

| Field | Required | Purpose |
|-------|----------|---------|
| `id` | Yes | Kebab-case identifier used in file paths and CLI |
| `name` | Yes | Human-readable name for CLI output |
| `description` | Yes | Short description shown in module info |
| `version` | Yes | Semver version stamped into generated file headers |
| `schema` | No | Prisma models and model name list |
| `schema.content` | Yes* | Template string containing Prisma model definitions |
| `schema.modelNames` | Yes* | Array of model names for tracking and uninstall |
| `frontend` | Yes | Frontend configuration block |
| `frontend.directories` | Yes | Folder structure to create in the feature directory |
| `frontend.templates` | Yes | `Record<string, string>` mapping relative paths to template content |
| `frontend.indexFiles` | Yes | Barrel files with side-effect registration imports |
| `frontend.shadcnComponents` | Yes | UI components to install (can be empty array) |
| `frontend.dependencies` | Yes | npm packages for the frontend (can be empty array) |
| `frontend.navigation` | Yes | Navigation metadata (actual config lives in template) |
| `frontend.routes` | Yes | Route metadata (actual routes live in template) |
| `frontend.registrations` | No | Array of registry registration files to generate |
| `backend` | No | Delete entirely for frontend-only modules |
| `backend.templates` | Yes* | `Record<string, string>` mapping filenames to template content |
| `backend.indexTemplate` | No | Custom barrel file (recommended over auto-generation) |
| `backend.dependencies` | No | npm packages for the backend |
| `backend.apiPath` | No | API route path (documentation) |
| `backend.hasInit` | No | Whether the module has an init function |
| `prompts` | No | Questions asked during `npx my-module init` |
| `features` | Yes | Feature list shown in post-install summary |
| `envVariables` | No | Split into `{ frontend: [], backend: [] }` |
| `requiredModules` | No | Module IDs that must be installed first |
| `lifecycle` | No | Hooks for install, update, activate, deactivate, uninstall |

Fields marked **Yes*** are required only when their parent block is present.

---

## Template Placeholders

Templates use placeholder patterns that get replaced during installation. This is how a single set of template files produces correctly named output for any module.

### Name Patterns

Every occurrence of these patterns is replaced with the corresponding case variant of your module ID.

| Pattern | Case | Example (id: `ai-chat`) |
|---------|------|------------------------|
| `my-feature` | kebab-case | `ai-chat` |
| `myFeature` | camelCase | `aiChat` |
| `MyFeature` | PascalCase | `AiChat` |
| `my_feature` | snake_case | `ai_chat` |

Use these patterns in file content, file paths, function names, component names, and Prisma model names. The scaffold replaces them everywhere.

### Variable Substitution

Variables from prompt answers use double-brace syntax. Add a pipe and default value for fallbacks.

```typescript
// Simple variable (replaced with prompt answer)
const provider = '{{provider}}';

// Variable with default fallback
const timeout = {{timeout|5000}};
const model = '{{model|gpt-4}}';
const region = '{{region|ap-southeast-2}}';
```

If the user does not answer the prompt (or the variable is not provided), the default value is used. Without a default, the placeholder is left as-is.

### Conditional Blocks

Templates support `{{#if}}` / `{{else}}` / `{{/if}}` blocks evaluated against prompt answers.

**Simple truthy check:**

```typescript
{{#if includeApi}}
import { api } from '@/lib/api';
{{/if}}
```

**Equality with else:**

```typescript
{{#if provider === 'stripe'}}
import Stripe from 'stripe';
const client = new Stripe(process.env.STRIPE_SECRET_KEY);
{{else}}
import { Paddle } from '@paddle/paddle-node-sdk';
const client = new Paddle(process.env.PADDLE_API_KEY);
{{/if}}
```

**Inequality check:**

```typescript
{{#if mode !== 'manual'}}
startAutoProcess();
{{/if}}
```

**Nesting:**

```typescript
{{#if includeApi}}
{{#if provider === 'stripe'}}
import Stripe from 'stripe';
{{/if}}
{{/if}}
```

**Truthiness rules:**
- Truthy: `true`, non-empty strings, non-zero numbers
- Falsy: `false`, `null`, `undefined`, `''`, `0`, variable not provided

Conditionals are evaluated **before** variable substitution. You can use `{{variable}}` placeholders inside conditional blocks and they will be substituted after the block is resolved.

See [Scaffold Architecture -- Conditional Blocks](/module-starter/scaffold/#conditional-blocks) for the full processing order and advanced usage.

---

## Adding Custom Template Files

The module starter ships with templates for the most common patterns. Larger modules often need more -- hooks, utilities, dialogs, context providers, or anything else your feature requires.

<Steps>
1. **Create the template file** in the appropriate directory.

   ```typescript
   // src/templates/frontend/hooks.ts
   export const USE_MY_FEATURE_HOOK = `// ========================================================================
   // FILE: frontend/src/features/my-feature/hooks/useMyFeature.ts
   // PURPOSE: Core hook for my-feature state and logic
   // ========================================================================

   import { useState, useCallback } from 'react';

   export function useMyFeature() {
     const [items, setItems] = useState<MyFeatureItem[]>([]);

     const refresh = useCallback(async () => {
       // Fetch items from API
     }, []);

     return { items, refresh };
   }
   `;

   export const USE_MY_FEATURE_CONFIG_HOOK = `// ========================================================================
   // FILE: frontend/src/features/my-feature/hooks/useMyFeatureConfig.ts
   // PURPOSE: Configuration hook for my-feature settings
   // ========================================================================

   import { useQuery } from '@tanstack/react-query';

   export function useMyFeatureConfig() {
     return useQuery({
       queryKey: ['my-feature-config'],
       queryFn: () => fetch('/api/v1/my-feature/config').then(r => r.json()),
     });
   }
   `;
   ```

2. **Export from the index file.** Add your new file to `src/templates/frontend/index.ts`:

   ```typescript
   // Hooks
   export { USE_MY_FEATURE_HOOK, USE_MY_FEATURE_CONFIG_HOOK } from './hooks.js';
   ```

3. **Reference in module.ts.** Add the templates to your frontend configuration:

   ```typescript
   frontend: {
     directories: ['pages', 'components', 'hooks', 'services', 'types', 'registrations'],
     templates: {
       // ... existing templates
       'hooks/useMyFeature.ts': frontend.USE_MY_FEATURE_HOOK,
       'hooks/useMyFeatureConfig.ts': frontend.USE_MY_FEATURE_CONFIG_HOOK,
     },
   },
   ```
</Steps>

### Guidelines

- **One file per category.** Group related templates together (all hooks in `hooks.ts`, all dialogs in `dialogs.ts`). Split into separate files if a single file gets too large.
- **Use the file header pattern.** Every template should start with the `// FILE:` and `// PURPOSE:` comment block. The scaffold adds a version header above this during installation.
- **Use placeholders.** Templates should use `my-feature`, `MyFeature`, `myFeature`, `my_feature` for name replacement, and `{{variable}}` for prompt-based values.
- **Add directories.** If your templates create files in new subdirectories, add those to `frontend.directories` (e.g., `'hooks'`, `'dialogs'`, `'utils'`).
- **Backend uses `.js` imports.** Any relative import in a backend template must use the `.js` extension for ESM compatibility.

<Aside type="tip">
Template files are just TypeScript files that export string constants. There is no limit to how many you can create. The `index.ts` barrel file re-exports everything so `module.ts` can import with `import * as frontend from './templates/frontend/index.js'`.
</Aside>

---

## Testing Your Module

<Steps>
1. **Build the module.**

   ```bash
   npm run build
   ```

2. **Link locally.**

   ```bash
   npm link
   ```

3. **Install in a test app.** Open a separate terminal and navigate to a starter template clone.

   ```bash
   cd ../my-test-app
   npx my-billing-module init
   ```

4. **Verify the installation.**
   - Check `frontend/src/features/billing/` exists with all expected files
   - Check `backend/src/features/billing/` exists (if your module has a backend)
   - Run the app with `npm run dev`
   - Navigate to your module's page in the browser
   - Confirm navigation items, routes, and registrations are working
</Steps>

<Aside type="tip">
After making changes to your templates, run `npm run build` again and re-install in the test app with `npx my-billing-module init --force` to overwrite previous files.
</Aside>

---

## Publishing

### Version Bump

Before publishing, bump the version. This updates both `package.json` and `src/module.ts`, commits the change, and creates a git tag.

```bash
npm run release:patch    # Bug fixes (1.0.0 -> 1.0.1)
npm run release:minor    # New features (1.0.0 -> 1.1.0)
npm run release:major    # Breaking changes (1.0.0 -> 2.0.0)
```

**Why this matters.** Every generated file gets a version header like `// @generated-by: billing v1.0.1 | hash: abc123`. The `update` command uses this version to detect changes and determine whether lifecycle hooks should run. If you change templates without bumping, `npx my-module update` will not detect the changes.

### npm Publish

```bash
npm publish
```

Users can then install your module with:

```bash
npx my-billing-module init
```

---

## Next Steps

- [Registry Guide](/module-starter/registry-guide/) -- How to register with the starter template's registries
- [File Reference](/module-starter/file-reference/) -- Detailed module file structure
- [Scaffold Architecture](/module-starter/scaffold/) -- How the scaffold infrastructure works
- [Code Templates](/module-starter/templates/) -- Copy-paste template reference
- [Lifecycle Hooks](/module-starter/lifecycle-hooks/) -- Filters, actions, and module lifecycle
