---
title: Starter Integration
description: How the module starter connects to the starter template's architecture
---

import { Aside, Tabs, TabItem } from '@astrojs/starlight/components';

Modules extend the starter template without editing its core files. The connection point is a set of **registries** — singleton objects that accept registrations from any module. This page covers the architectural alignment between the module starter's templates and the starter template's registries.

<Aside type="tip">
This page contains summary tables and the sync guide. For practical usage examples with full code snippets, see the [Registry Guide](/module-starter/registry-guide/). For the complete API reference (all fields, types, and options), see [Registry Reference](/starter-template/registries/).
</Aside>

---

## The Registry Pattern

Modules never modify core files. Instead, they register with singleton registries that the app reads at runtime. Each registry handles one integration point — navigation, dashboard, routes, and so on.

A module's registration file imports the registry, calls its method, and the app picks it up automatically.

```typescript
// Registration file — runs on import, no exports needed
import { navigationRegistry } from '@/config/navigation.registry';
import { dashboardRegistry } from '@/config/dashboard.registry';
import { settingsPagesRegistry } from '@/config/settings-pages.registry';

navigationRegistry.registerMain({ id: 'my-feature', title: 'My Feature', url: '/my-feature', icon: Sparkles, order: 50 });
dashboardRegistry.register({ id: 'my-feature-widget', title: 'My Feature', component: MyFeatureWidget, size: '2x1', order: 50 });
settingsPagesRegistry.register({ id: 'my-feature', title: 'My Feature', component: MyFeatureSettingsPage, order: 60 });
```

The app never needs to know which modules are installed. It reads the registries and renders whatever has been registered.

---

## Side-Effect Import Pattern

Registration files run code on import. They do not export anything. The feature's barrel `index.ts` imports them **first**, before any named exports. This ensures registrations execute before any component renders.

```typescript
// features/my-feature/index.ts
import './my-feature.registration';     // Side-effect: registers with app registries
import './my-feature.nav.registration'; // Side-effect: registers navigation items

export { MyFeaturePage } from './pages/MyFeaturePage';
export { MyFeatureWidget } from './components/widgets/MyFeatureWidget';
```

This mirrors how the starter template's own built-in features (dashboard, admin, user) register themselves. Every feature — built-in or module-provided — uses the same pattern.

---

## Frontend Registries

| Registry | Import From | Method | Purpose |
|----------|-------------|--------|---------|
| Navigation | `@/config/navigation.registry` | `registerMain()`, `registerSecondary()`, `registerUserMenu()` | Sidebar & menu items |
| Dashboard | `@/config/dashboard.registry` | `register()` | Dashboard widgets |
| Settings Pages | `@/config/settings-pages.registry` | `register()` | Settings section pages |
| Admin Pages | `@/config/admin-pages.registry` | `register()` | Admin panel pages |
| Preferences | `@/config/preferences.registry` | `register()` | User preference sections |
| Integrations | `@/config/integrations.registry` | `register()` | Third-party integrations |
| Header Toolbar | `@/config/header-toolbar.registry` | `register()` | Header buttons & dropdowns |
| Personal Info | `@/config/personal-info-fields.registry` | `register()`, `registerCategory()` | Profile page fields |
| Filter | `@/config/filter.registry` | `register()` | Data transformation pipeline |
| Action | `@/config/action.registry` | `addAction()`, `addActionAsync()` | Side-effect hooks |

---

## Backend Registries

Backend registrations use relative paths with `.js` extensions (ESM requirement).

| Registry | Import From | Method | Purpose |
|----------|-------------|--------|---------|
| Routes | `../../config/route.registry.js` | `register()` | API route mounting |
| Services | `../../config/service.registry.js` | `register()`, `registerDynamic()` | Business logic access |
| Filter | `../../config/filter.registry.js` | `register()`, `registerAsync()` | Data transformation pipeline |
| Action | `../../config/action.registry.js` | `addAction()`, `addActionAsync()` | Side-effect hooks |

---

## Keeping Templates in Sync

When the starter template's registries change, module templates need to match. Registry APIs, import paths, and interface shapes all flow from the starter template into the module starter's template strings.

| If Starter Template Changes... | Update in Module Starter... |
|-------------------------------|---------------------------|
| Registry API (method names, parameters) | `src/templates/frontend/registrations.ts` and `src/templates/backend/registrations.ts` |
| Registry import paths | Same registration template files |
| Route configuration patterns | `src/templates/frontend/routes.ts` |
| Feature barrel file pattern | `src/templates/frontend/routes.ts` (INDEX_TEMPLATE) and `src/templates/backend/routes.ts` |
| `DashboardWidgetProps` interface | `src/templates/frontend/components.ts` (WIDGET_COMPONENT_TEMPLATE) |
| Backend service patterns | `src/templates/backend/services.ts` |
| Integration categories | `src/templates/frontend/registrations.ts` and `src/scaffold/types.ts` |

<Aside type="caution">
After changing any template file in the module starter, bump the scaffold version with `npm run scaffold:version:patch`. Without this, cloned modules will not pick up the changes via `scaffold:update`.
</Aside>

---

## Next Steps

- [Registry Guide](/module-starter/registry-guide/) — Practical usage examples for every registry
- [Registry Reference](/starter-template/registries/) — Full API reference with all fields, types, and options
- [Scaffold Architecture](/module-starter/scaffold/) — How auto-registration works during installation
- [Versioning](/module-starter/versioning/) — Version bumping and change propagation
