---
title: Versioning & Updates
description: How versioning works and how changes propagate through the module system
---

import { Aside, Tabs, TabItem, Steps } from '@astrojs/starlight/components';

Understanding the versioning and update system is critical — it controls how changes propagate from the module starter, through individual modules, and into apps.

---

## How the System Fits Together

The module system is a chain of three repositories, each with its own update mechanism:

```
Starter Template
  ↓ template:update (git merge via template-upstream)
App (starter template clone)
  ↑ npx my-module init / update
Individual Module (e.g., ai-chat-module)
  ↑ scaffold:update (git merge via scaffold-upstream)
Module Starter (template repo)
```

When you work on the **module starter**, your changes can affect every module cloned from it, and every app those modules are installed into.

---

## Two Version Systems

The module system tracks two separate version numbers for different purposes:

| Version | Stored In | When to Bump | Who Uses It |
|---------|-----------|--------------|-------------|
| **Scaffold Version** | `VERSION` file | After **any** change in the module starter repo | Cloned modules — used when checking for scaffold updates |
| **Module Version** | `package.json` + `src/module.ts` | After changing templates in a **cloned module** | Apps — the `update` command uses this to detect changes |

<Aside type="caution">
**Important distinction:** When you are working in the **module starter repo itself**, every change is a scaffold version bump — templates, scaffold files, scripts, everything. The module version bump (`npm run version:patch`) is only used when working in a **cloned module** (e.g., `ai-chat-module`) after you've customised its templates.
</Aside>

---

## Version Headers

Every file generated by a module gets a version header on the first line:

```typescript
// @generated-by: ai-chat v1.2.0 | hash: a3f8b2c1
```

This header contains:
- **Module ID** — Which module generated this file
- **Module version** — The version at generation time
- **Template hash** — MD5 hash (first 8 chars) of the template content

The `update` command uses headers to make smart decisions:

| Scenario | Header Hash vs File | Template Changed? | Action |
|----------|-------------------|-------------------|--------|
| No changes | Match | No | Skip |
| Template updated | Match | Yes | Update file |
| User modified file | Mismatch | No | Skip (warn) |
| Both changed | Mismatch | Yes | Conflict (manual review) |

### Migrate Command

For files that predate the header system, `npx my-module migrate` adds version headers to existing files by matching them against current templates.

<Aside type="caution">
**If you change templates without bumping the version**, `npx my-module update` won't detect the changes and apps won't get updated files. Always bump after template changes.
</Aside>

---

## Version Bump Commands

All commands work cross-platform (PowerShell → Bash fallback via `scripts/run.cjs`):

### In the Module Starter (this repo)

**Any change = scaffold version bump.** The module starter IS the scaffold.

| Change | Command |
|--------|---------|
| `src/scaffold/**/*.ts` | `npm run scaffold:version:patch` |
| `src/templates/**/*.ts` | `npm run scaffold:version:patch` |
| `src/module.ts` | `npm run scaffold:version:patch` |
| `scripts/*`, config files | `npm run scaffold:version:patch` |
| `docs/*` | No bump (push submodule) |
| `CLAUDE.md`, `README.md` | No bump |

### In a Cloned Module

After customising your module's templates, bump the **module version** so downstream apps detect the changes:

```bash
# Bump + auto-commit
npm run version:patch    # Bug fixes (1.0.0 → 1.0.1)
npm run version:minor    # New features (1.0.0 → 1.1.0)
npm run version:major    # Breaking changes (1.0.0 → 2.0.0)

# Bump + auto-commit + git tag (for publishing)
npm run release:patch    # Creates v1.0.1 tag
npm run release:minor    # Creates v1.1.0 tag
npm run release:major    # Creates v2.0.0 tag
```

The version bump scripts update **both** `package.json` and `src/module.ts` to keep them in sync.

---

## Update Mechanism

When a user runs `npx my-module update`, the scaffold compares every installed template against the current version:

<Steps>
1. **Find installed module** — Reads the manifest to locate all generated files

2. **For each template file:**
   - Parse the version header (extract old version, old hash)
   - Load the current template from the module
   - Process placeholders and calculate new hash
   - Compare hashes to detect changes

3. **Decision tree:**
   - Template unchanged (same hash) → **Skip** (nothing to do)
   - Template changed, file unmodified → **Update** (safe to overwrite)
   - Template unchanged, file modified → **Skip** (user's changes preserved)
   - Both changed → **Conflict** (flag for manual review)

4. **Detect schema changes** — Compares the current Prisma schema template against the installed schema. If changes are detected, prompts the user to update (or auto-applies with `--force`). Uses stored `moduleAnswers` for variable substitution. Use `--skip-schema` to skip this step.

5. **Run lifecycle hook** — If the module version changed, runs `onUpdate` with rich context including `fromVersion`, `toVersion`, `schemaChanged`, `moduleAnswers`, and a `changes` object listing all updated/added/removed files
</Steps>

### Dry Run

Preview what would change without applying:

```bash
npx my-module update --dry-run
```

---

## Manifest System

The scaffold tracks everything it installs in `.module-manifests.json` at the project root. This enables clean uninstallation and update detection.

```json
{
  "ai-chat": {
    "moduleId": "ai-chat",
    "moduleName": "AI Chat Module",
    "version": "1.2.0",
    "installedAt": "2025-01-15T10:30:00Z",
    "frontendPath": "frontend/src/features/ai-chat",
    "backendPath": "backend/src/features/ai-chat",
    "registrations": [
      { "file": "frontend/src/routes.tsx", "type": "import", "content": "aiChatRoutes" },
      { "file": "frontend/src/routes.tsx", "type": "spread", "content": "...aiChatRoutes" },
      { "file": "backend/src/app.ts", "type": "import", "content": "./features/ai-chat/index.js" }
    ],
    "schemaModels": ["ai_chat_message", "ai_chat_conversation"],
    "schemaFile": "backend/prisma/ai-chat.prisma"
  }
}
```

---

## Uninstalling

The `uninstall` command uses the manifest to cleanly remove a module:

```bash
npx my-module uninstall              # Interactive removal
npx my-module uninstall --force      # Skip confirmation
npx my-module uninstall --keep-data  # Keep database tables
npx my-module uninstall --export ./  # Export data before removing
```

What gets removed:
- All generated files and directories listed in the manifest
- Import statements and route spreads from `routes.tsx` and `app.ts`
- Prisma models from the schema file
- The module's manifest entry

The `onUninstall` lifecycle hook runs before removal, allowing the module to offer data export or clean up external resources. If no modules remain after uninstall, the `.module-manifests.json` file is deleted.

<Aside type="caution">
**Manual steps required after uninstall:**
- Remove npm dependencies that may be shared with other modules (check before deleting)
- Remove environment variables from `.env` files
- Run `npx prisma generate` and `npx prisma migrate dev` to sync the database
</Aside>

---

## Scaffold Updates

These commands exist in **cloned modules** (not the module starter template itself):

```bash
npm run scaffold:check    # Preview what's changed in the module starter
npm run scaffold:update   # Merge module starter changes into this module
```

### How It Works

<Steps>
1. The create script (`create-module.ps1`/`.sh`) clones the module starter and renames `origin` to `scaffold-upstream`
2. You add your own `origin` remote for your module's repository
3. When the module starter is updated, `scaffold:check` fetches from `scaffold-upstream` and shows new commits
4. `scaffold:update` merges those changes via git — same as any git merge
5. Conflicts are resolved normally (rare, since scaffold files are marked DO NOT EDIT)
</Steps>

### What Gets Updated vs Preserved

<Tabs>
  <TabItem label="Updated">
| Path | Contents |
|------|----------|
| `src/scaffold/*` | Init, update, uninstall logic |
| `src/cli.ts` | CLI entry point |
| `scripts/*` | Build and version scripts |
| `tsconfig.json`, `tsup.config.ts` | Build configuration |
| `VERSION` | Scaffold version |
  </TabItem>
  <TabItem label="Preserved">
| Path | Contents |
|------|----------|
| `src/templates/*` | Your custom templates |
| `src/module.ts` | Your module configuration |
| `package.json` | Your module name, version, dependencies |
| `CLAUDE.md` | Your module-specific instructions |
| `.env` files | Your credentials |
  </TabItem>
</Tabs>

### After Updating

<Steps>
1. **Install dependencies** (if the scaffold added new ones):
   ```bash
   npm install
   ```

2. **Rebuild your module:**
   ```bash
   npm run build
   ```

3. **Test your module:**
   ```bash
   npm link
   # In a test project:
   npx your-module init
   ```

4. **Push your changes**
</Steps>

### Handling Conflicts

Conflicts are rare because scaffold files are marked "DO NOT EDIT". But if they occur, use this strategy:

| File | Strategy |
|------|----------|
| `scripts/*`, `VERSION`, `update-scaffold.*` | **Accept incoming** — scaffold infrastructure |
| `src/cli.ts`, `src/scaffold/*`, `src/index.ts` | **Accept incoming** — scaffold logic |
| `tsconfig.json`, `tsup.config.ts` | **Accept incoming** — build config |
| `src/module.ts` | **Mix** — keep your config, accept new structure |
| `src/templates/*` | **Accept current** — your module's templates |
| `package.json` | **Mix** — keep your name/version/deps, accept new scripts |

```bash
# Accept incoming (scaffold files)
git checkout --theirs path/to/file
git add path/to/file

# Accept current (your module files)
git checkout --ours path/to/file
git add path/to/file

# Mix (manual merge required — resolve conflict markers, then stage)
git add path/to/file

# Complete the merge
git commit -m "chore: merge scaffold updates"
```

**For `src/module.ts` (Mix):** Keep your `id`, `name`, `description`, `version`, `templates`, `prompts`, and `envVariables`. Accept any new optional fields or structure changes from the scaffold.

**For `package.json` (Mix):** Keep your `name`, `version`, `description`, `bin`, and dependencies. Accept new npm scripts (`scaffold:*`, `version:*`, `release:*`) and updated devDependencies.

<Aside type="tip">
Avoid modifying scaffold files. If you need changes to the scaffold infrastructure, report them upstream to the module starter repo.
</Aside>

### Legacy Modules (Pre-Git-Clone)

If your module was created before the git clone approach (file copy method), there is no shared git history. The update script detects this and uses a **selective checkout** strategy instead of merge — it checks out specific scaffold files from upstream while preserving your module files.

After a successful selective checkout, the script automatically establishes a shared history connection so future updates can use normal git merge. If the connection fails, you can establish it manually:

```bash
git fetch scaffold-upstream main
git merge scaffold-upstream/main --allow-unrelated-histories -s ours -m "chore: establish scaffold history connection"
```

### When to Update

Update the scaffold when:

- Bug fixes are released to the scaffold
- New CLI features are added (e.g., new commands)
- You want the latest infrastructure improvements

You do not need to update for every scaffold change. Run `npm run scaffold:check` to see what has changed before deciding.

---

## Impact of Changes

When working on the **module starter template**, understand the downstream impact:

| What You Change | Who's Affected | How They Get It |
|----------------|---------------|-----------------|
| `src/scaffold/*` | All cloned modules | `npm run scaffold:update` |
| `src/templates/*` | All cloned modules (as new defaults) | `npm run scaffold:update` |
| `scripts/*`, config files | All cloned modules | `npm run scaffold:update` |

<Aside type="note">
Changes to templates have a **two-hop propagation**: module starter → module (via scaffold:update) → app (via npx update). The module must be rebuilt (`npm run build`) before apps can update. The scaffold bump happens in the module starter; the module version bump happens in the cloned module.
</Aside>

---

## Next Steps

- [Scaffold Architecture](/module-starter/scaffold/) — Installation pipeline and auto-registration
- [Building Your Module](/module-starter/building-modules/) — Template authoring and testing
- [File Reference](/module-starter/file-reference/) — File structure and naming conventions
- [Create Script Walkthrough](/module-starter/create-script/) — How the scaffold-upstream remote is set up
