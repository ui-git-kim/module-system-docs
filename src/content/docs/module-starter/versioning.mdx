---
title: Versioning & Updates
description: How versioning works and how changes propagate through the module system
---

import { Aside, Tabs, TabItem, Steps } from '@astrojs/starlight/components';

Understanding the versioning and update system is critical — it controls how changes propagate from the module starter, through individual modules, and into apps.

---

## How the System Fits Together

The module system is a chain of three repositories, each with its own update mechanism:

```
Starter Template
  ↓ template:update (git merge via template-upstream)
App (starter template clone)
  ↑ npx my-module init / update
Individual Module (e.g., ai-chat-module)
  ↑ scaffold:update (git merge via scaffold-upstream)
Module Starter (template repo)
```

When you work on the **module starter**, your changes can affect every module cloned from it, and every app those modules are installed into. That's why versioning matters.

---

## Two Update Flows

Changes propagate through two distinct mechanisms:

### 1. Module Starter → Individual Module (Git Merge)

When the module starter is improved (scaffold fixes, new template features, build config updates), cloned modules pull those changes via git merge.

| | Details |
|---|---|
| **Mechanism** | `git fetch scaffold-upstream && git merge` |
| **Remote** | `scaffold-upstream` (set up by create script) |
| **What updates** | Scaffold infrastructure, template starters, build config, scripts |
| **What's preserved** | Your custom templates, module.ts, package.json |
| **Commands** | `npm run scaffold:check` / `npm run scaffold:update` |

This is the same pattern as the starter template → app update:

| System | Source | Target | Remote | Command |
|--------|--------|--------|--------|---------|
| Starter Template → App | Template repo | App repo | `template-upstream` | `npm run template:update` |
| Module Starter → Module | Module starter repo | Module repo | `scaffold-upstream` | `npm run scaffold:update` |

### 2. Individual Module → App (Template Hash Diffing)

When an app runs `npx my-module update`, the module compares template content hashes to detect what's changed and updates generated files accordingly.

| | Details |
|---|---|
| **Mechanism** | Template content hash comparison |
| **What updates** | Generated feature files in `frontend/src/features/` and `backend/src/features/` |
| **What's preserved** | Files the user has manually modified (hash mismatch warning) |
| **Commands** | `npx my-module update` / `npx my-module update --dry-run` |

---

## Two Version Systems

The module system tracks two separate version numbers for different purposes:

| Version | Stored In | When to Bump | Who Uses It |
|---------|-----------|--------------|-------------|
| **Scaffold Version** | `VERSION` file | After **any** change in the module starter repo | Cloned modules — used when checking for scaffold updates |
| **Module Version** | `package.json` + `src/module.ts` | After changing templates in a **cloned module** | Apps — the `update` command uses this to detect changes |

<Aside type="caution">
**Important distinction:** When you are working in the **module starter repo itself**, every change is a scaffold version bump — templates, scaffold files, scripts, everything. The module version bump (`npm run version:patch`) is only used when working in a **cloned module** (e.g., `ai-chat-module`) after you've customised its templates.
</Aside>

### Version Headers

Every file generated by a module gets a version header:

```typescript
// @generated-by: ai-chat v1.2.0 | hash: a3f8b2c1
```

- The **hash** is computed from the template content — `npx my-module update` compares the installed hash with the current hash to detect whether a template has changed
- The **version** tells the update command what version generated the file, and determines whether lifecycle hooks (like database migrations) need to run

### Why Bumping Matters

<Aside type="caution">
**If you change templates without bumping the version**, `npx my-module update` won't detect the changes and apps won't get updated files. Always bump after template changes.
</Aside>

The version bump scripts update **both** `package.json` and `src/module.ts` to keep them in sync. This is important because `module.ts` is what the scaffold reads at build time, and `package.json` is what npm uses for distribution.

---

## Version Bump Commands

All commands work cross-platform (PowerShell → Bash fallback via `scripts/run.cjs`):

### Module Version

Bump after changing `src/templates/*` or `src/module.ts`:

```bash
# Bump + auto-commit
npm run version:patch    # Bug fixes (1.0.0 → 1.0.1)
npm run version:minor    # New features (1.0.0 → 1.1.0)
npm run version:major    # Breaking changes (1.0.0 → 2.0.0)

# Bump + auto-commit + git tag (for publishing)
npm run release:patch    # Creates v1.0.1 tag
npm run release:minor    # Creates v1.1.0 tag
npm run release:major    # Creates v2.0.0 tag
```

### Scaffold Version

Bump after changing `src/scaffold/*` (rare — most work is in templates):

```bash
npm run scaffold:version:patch
npm run scaffold:version:minor
npm run scaffold:version:major
```

### What Triggers What

#### In the Module Starter (this repo)

**Any change = scaffold version bump.** The module starter IS the scaffold.

| Change | Command |
|--------|---------|
| `src/scaffold/**/*.ts` | `npm run scaffold:version:patch` |
| `src/templates/**/*.ts` | `npm run scaffold:version:patch` |
| `src/module.ts` | `npm run scaffold:version:patch` |
| `scripts/*`, config files | `npm run scaffold:version:patch` |
| `docs/*` | No bump (push submodule) |
| `CLAUDE.md`, `README.md` | No bump |

#### In a Cloned Module (e.g., ai-chat-module)

After customising your module's templates, bump the **module version** so downstream apps detect the changes:

| Change | Command |
|--------|---------|
| `src/templates/**/*.ts` | `npm run version:patch` |
| `src/module.ts` | `npm run version:patch` |
| `src/scaffold/**/*.ts` | ❌ Don't edit — use `scaffold:update` instead |

---

## Scaffold Update Commands

These commands exist in **cloned modules** (not the module starter template itself):

```bash
# Preview what's changed in the module starter
npm run scaffold:check

# Merge module starter changes into this module
npm run scaffold:update
```

### How It Works

<Steps>
1. The create script (`create-module.ps1`/`.sh`) clones the module starter and renames `origin` to `scaffold-upstream`
2. You add your own `origin` remote for your module's repository
3. When the module starter is updated, `scaffold:check` fetches from `scaffold-upstream` and shows new commits
4. `scaffold:update` merges those changes via git — same as any git merge
5. Conflicts are resolved normally (rare, since scaffold files are marked DO NOT EDIT)
</Steps>

### What Gets Updated vs Preserved

<Tabs>
  <TabItem label="Updated">
| Path | Contents |
|------|----------|
| `src/scaffold/*` | Init, update, uninstall logic |
| `src/cli.ts` | CLI entry point |
| `scripts/*` | Build and version scripts |
| `tsconfig.json`, `tsup.config.ts` | Build configuration |
| `VERSION` | Scaffold version |
  </TabItem>
  <TabItem label="Preserved">
| Path | Contents |
|------|----------|
| `src/templates/*` | Your custom templates |
| `src/module.ts` | Your module configuration |
| `package.json` | Your module name, version, dependencies |
| `CLAUDE.md` | Your module-specific instructions |
| `.env` files | Your credentials |
  </TabItem>
</Tabs>

### Handling Conflicts

If both you and the module starter modified the same file:

```bash
# Keep your version
git checkout --ours path/to/file

# Take module starter version
git checkout --theirs path/to/file

# After resolving
git add path/to/file
git commit
```

<Aside type="tip">
Conflicts are rare because the scaffold files are marked "DO NOT EDIT". If you haven't modified scaffold files, merges will be clean.
</Aside>

---

## Impact of Changes

When working on the **module starter template**, understand the downstream impact:

| What You Change | Who's Affected | How They Get It | Version to Bump |
|----------------|---------------|-----------------|-----------------|
| `src/scaffold/*` | All cloned modules | `npm run scaffold:update` | Scaffold (`VERSION`) |
| `src/templates/*` | All cloned modules (as new defaults) | `npm run scaffold:update` | Scaffold (`VERSION`) |
| `scripts/*`, config files | All cloned modules | `npm run scaffold:update` | Scaffold (`VERSION`) |

After a cloned module pulls scaffold updates and customises its templates, **that module** bumps its own module version. Then apps detect the change via `npx my-module update`.

<Aside type="note">
Changes to templates have a **two-hop propagation**: module starter → module (via scaffold:update) → app (via npx update). The module must be rebuilt (`npm run build`) before apps can update. The scaffold bump happens in the module starter; the module version bump happens in the cloned module.
</Aside>

---

## Next Steps

- [Scaffold Architecture](/module-starter/scaffold/) — How the scaffold infrastructure works
- [Creating Modules](/module-starter/creating-modules/) — Includes scaffold update setup
- [Module Structure](/module-starter/module-structure/) — File reference and order conventions
- [Updating Cloned Apps](/starter-template/updating/) — The equivalent system for the starter template
