---
title: Developer Workflow
description: How to work on the module starter template itself — editing, versioning, testing, and propagating changes
sidebar:
  order: 45
---

import { Aside, Tabs, TabItem, Steps } from '@astrojs/starlight/components';

This page covers working on the **module starter template itself** — the upstream repository that all modules are cloned from. If you are building a module (a clone), see [Building Your Module](/module-starter/building-modules/) instead.

<Aside type="caution">
The module starter is a **template repository**, not a runnable application. It has no `node_modules` by design. You do not run `npm install`, `npm run build`, or `npm run dev` here. Changes are tested by cloning a fresh module or running `scaffold:update` in an existing module.
</Aside>

---

## What to Edit

| Path | Purpose | Edit? |
|------|---------|-------|
| `src/templates/**/*.ts` | Template file content that modules generate | **Yes** |
| `src/module.ts` | Example module configuration | **Yes** |
| `src/scaffold/**/*.ts` | Scaffold infrastructure (init, update, uninstall, etc.) | **Yes** (bug fixes, features) |
| `src/cli.ts` | CLI entry point and command routing | **Yes** (new commands) |
| `scripts/*` | Version bump and utility scripts | **Yes** (improvements) |
| `CLAUDE.md` | AI assistant instructions for the module starter | **Yes** |
| `CLAUDE.MODULE.md` | Template CLAUDE.md for cloned modules | **Yes** |
| `docs/` | Documentation submodule | **Yes** (then push separately) |

<Aside type="tip">
In the module starter, **everything** is scaffold. Unlike cloned modules where you only edit templates, here you can edit scaffold files too — you ARE the upstream.
</Aside>

---

## Two Version Systems

The module starter tracks two separate version numbers. Understanding the difference is critical.

| Version | File | Purpose | Bump Command |
|---------|------|---------|--------------|
| **Scaffold Version** | `VERSION` | Tracks infrastructure changes. Cloned modules use this to check for updates. | `npm run scaffold:version:patch` |
| **Module Version** | `package.json` + `src/module.ts` | Tracks template changes in cloned modules. Apps use this for `npx update`. | `npm run version:patch` (only in clones) |

### In the Module Starter Repo

**Every change is a scaffold version bump.** This repo IS the scaffold. The module version bump (`npm run version:patch`) is only used in cloned modules.

```bash
# After ANY code change in this repo
npm run scaffold:version:patch    # Bug fix, docs alignment
npm run scaffold:version:minor    # New feature, new template, new command
npm run scaffold:version:major    # Breaking change
```

### When to Bump

| Change | Bump? | Level |
|--------|-------|-------|
| `src/templates/**/*.ts` | Yes | `patch` (content change) or `minor` (new template) |
| `src/scaffold/**/*.ts` | Yes | `patch` (fix) or `minor` (new feature) |
| `src/module.ts` | Yes | `patch` |
| `src/cli.ts` | Yes | `patch` or `minor` |
| `scripts/*` | Yes | `patch` |
| `CLAUDE.md`, `CLAUDE.MODULE.md` | No | — |
| `README.md` | No | — |
| `docs/*` | No | Push submodule instead |

---

## Making Changes

### Template Changes

Templates are string constants in `src/templates/`. When you change a template, the change becomes available to cloned modules via `scaffold:update`.

<Steps>
1. **Edit the template file** in `src/templates/frontend/` or `src/templates/backend/`
2. **Update the barrel file** if you added a new template export (`src/templates/frontend/index.ts` or `src/templates/backend/index.ts`)
3. **Update `src/module.ts`** if the new template needs to be referenced in the example configuration
4. **Bump the scaffold version:**
   ```bash
   npm run scaffold:version:patch
   ```
5. **Commit and push:**
   ```bash
   git add src/templates/ src/module.ts
   git commit -m "feat: add new template for X"
   git push
   ```
</Steps>

### Scaffold Changes

Scaffold files (`src/scaffold/`) contain the CLI logic. Changes here affect how `init`, `update`, `uninstall`, etc. work across all modules.

<Steps>
1. **Edit the scaffold file** (e.g., `src/scaffold/init.ts`)
2. **Bump the scaffold version:**
   ```bash
   npm run scaffold:version:patch
   ```
3. **Commit and push:**
   ```bash
   git add src/scaffold/
   git commit -m "fix: handle edge case in schema detection"
   git push
   ```
</Steps>

<Aside type="caution">
Scaffold changes affect **every** cloned module. Test thoroughly before pushing. Consider edge cases — single-file vs multi-file Prisma setups, frontend-only modules, modules with prompts, etc.
</Aside>

---

## Testing Changes

Since the module starter is not a runnable project, you test changes by using them in a real module.

### Option 1: Fresh Module Clone

Create a new module from the updated template:

<Tabs>
  <TabItem label="Windows">
    ```powershell
    .\create-module.ps1
    # Enter a test module name like "test-module"
    # The clone includes your latest changes
    ```
  </TabItem>
  <TabItem label="macOS/Linux">
    ```bash
    ./create-module.sh
    ```
  </TabItem>
</Tabs>

Then build and test the module:

```bash
cd ../test-module
npm run build
npm link

# In a starter template project:
cd ../my-test-app
npx test-module init
```

### Option 2: Scaffold Update in Existing Module

If you have an existing cloned module, pull the scaffold changes:

```bash
cd ../ai-chat-module
npm run scaffold:update
npm run build
```

Then test installation in a starter template project.

### What to Verify

- [ ] `npx my-module init` completes without errors
- [ ] Generated files have correct placeholder replacements
- [ ] Version headers are present on all generated files
- [ ] Auto-registration works (routes.tsx, app.ts)
- [ ] `npx my-module update` detects changes correctly
- [ ] `npx my-module uninstall` removes everything cleanly
- [ ] Frontend and backend code compiles in the target project
- [ ] Routes, navigation, and registrations work at runtime

---

## How Changes Propagate

Changes in the module starter follow a **two-hop propagation** path:

```
Module Starter (this repo)
  ↓ scaffold:update (git merge via scaffold-upstream remote)
Cloned Module (e.g., ai-chat-module)
  ↓ npm run build → npx my-module init/update
Starter Template App (target project)
```

| Step | Who Does It | Command |
|------|-------------|---------|
| 1. Push changes to module starter | You (scaffold developer) | `git push` |
| 2. Pull scaffold updates into module | Module developer | `npm run scaffold:update` |
| 3. Rebuild the module | Module developer | `npm run build` |
| 4. Bump module version | Module developer | `npm run version:patch` |
| 5. Install/update in app | App developer | `npx my-module init` or `npx my-module update` |

<Aside type="note">
Template changes in the module starter become the **new defaults** for cloned modules. Module developers who have already customised their templates will see the changes as incoming during `scaffold:update` — they can accept, reject, or merge them.
</Aside>

---

## Documentation Workflow

The `docs/` folder is a git submodule. Changes must be pushed separately.

<Steps>
1. **Edit documentation files** in `docs/src/content/docs/`
2. **Push the docs submodule:**
   ```bash
   cd docs
   git add .
   git commit -m "Docs: description of changes"
   git push
   cd ..
   ```
3. **Update the submodule reference in the main repo:**
   ```bash
   git add docs
   git commit -m "docs: update docs submodule"
   git push
   ```
</Steps>

<Aside type="tip">
Documentation changes do **not** require a scaffold version bump. The docs site deploys independently.
</Aside>

---

## Pre-Commit Checklist

Before committing any changes to the module starter:

- [ ] **Scaffold version bumped** — Run `npm run scaffold:version:patch` for any code change
- [ ] **File headers present** — New template files have `// FILE:` and `// PURPOSE:` headers
- [ ] **Backend imports use `.js`** — All relative imports in backend templates use `.js` extension
- [ ] **Placeholders used** — Templates use `my-feature`, `MyFeature`, `myFeature`, `my_feature`, `My Feature`, `my feature` patterns
- [ ] **CLAUDE.MODULE.md updated** — If scaffold structure changed, update the module-level instructions
- [ ] **TypeScript valid** — Template string constants use correct TypeScript syntax
- [ ] **Tested** — Changes verified in a fresh clone or via `scaffold:update`

---

## Impact Assessment

Before pushing changes, consider the downstream impact:

| Change Type | Impact | Risk |
|-------------|--------|------|
| New template file | Low — modules can adopt it optionally | Low |
| Modified template | Medium — modules get it via `scaffold:update` as merge | Medium |
| New scaffold feature | Medium — available to all modules after update | Low |
| Scaffold bug fix | High — all modules benefit after update | Low |
| Breaking scaffold change | High — all modules must update and may need migration | High |
| CLI command change | Medium — changes user-facing behaviour | Medium |

For **breaking changes**, bump `scaffold:version:major` and document migration steps in the changelog.

---

## Next Steps

- [Scaffold Architecture](/module-starter/scaffold/) — How the scaffold infrastructure works
- [Versioning & Updates](/module-starter/versioning/) — Version headers, update mechanism, manifest system
- [Changelog](/module-starter/changelog/) — Version history
- [Building Your Module](/module-starter/building-modules/) — Guide for module developers (not scaffold developers)
