---
title: Module Starter Overview
description: Create distributable module packages for the starter template
---

import { Aside, Steps, Tabs, TabItem } from '@astrojs/starlight/components';

The **Module Starter** is a template repository for creating installable module packages. When you clone it and customise the templates, you get a CLI tool that can scaffold fullstack features into apps built with the [Starter Template](/starter-template/).

<Aside type="tip">
The module starter creates **npm packages** with CLI commands like `npx my-module init`. It's not just a folder structure—it's a distribution system.
</Aside>

---

## How It Works

<Steps>
1. **Clone** the module starter to create a new module package
2. **Customise** the templates in `src/templates/`
3. **Build** with `npm run build`
4. **Distribute** via npm or direct installation
5. **Install** into apps using `npx my-module init`
</Steps>

The module starter handles all the scaffolding logic—you just write templates.

---

## Package Structure

The module starter has two distinct parts: **scaffold infrastructure** (shared, don't edit) and **your templates** (customise these).

```
module-starter/
├── src/
│   ├── module.ts           # Module configuration (EDIT THIS)
│   ├── cli.ts              # CLI entry point (DO NOT EDIT)
│   ├── scaffold/           # Scaffolding infrastructure (DO NOT EDIT)
│   │   ├── init.ts         # Installation logic
│   │   ├── update.ts       # Update logic
│   │   ├── uninstall.ts    # Uninstall logic
│   │   └── ...
│   └── templates/          # Your templates (EDIT THESE)
│       ├── schema.ts       # Prisma schema templates
│       ├── frontend/       # Frontend file templates
│       └── backend/        # Backend file templates
├── package.json            # Module package config
├── VERSION                 # Scaffold infrastructure version
└── CLAUDE.md               # AI assistant instructions
```

For the full file reference including what to edit and what not to, see [Module Structure](/module-starter/module-structure/). For how the scaffold infrastructure works internally, see [Scaffold Architecture](/module-starter/scaffold/).

---

## Key Concepts

### Template Placeholders

Templates use `my-feature` as a placeholder that gets replaced during installation:

| Placeholder | Replaced With | Example |
|-------------|--------------|---------|
| `my-feature` | moduleId (kebab-case) | `ai-chat` |
| `myFeature` | camelCase | `aiChat` |
| `MyFeature` | PascalCase | `AiChat` |
| `my_feature` | snake_case | `ai_chat` |

### Registry Pattern

Generated code integrates with the app through **registries** — singleton objects that modules register with instead of editing shared files. This is the core architectural principle of the module system.

Your module registers navigation items, dashboard widgets, settings pages, API routes, services, and more — all without touching the app's core code.

For the complete list of available registries, how to use them, and examples, see [Registry Integration](/module-starter/registry-integration/).

### Self-Contained Schemas

Module Prisma schemas must have **no `@relation` directives**:

```prisma
// CORRECT - self-contained
model ai_chat_message {
  id        String   @id @default(cuid())
  userId    String                          // Plain FK, not a relation
  content   String
  createdAt DateTime @default(now())

  @@index([userId])
}
```

---

## CLI Commands

After building your module, these commands become available:

```bash
npx my-module init              # Install module into project
npx my-module init --force      # Overwrite existing files
npx my-module update            # Update to latest templates
npx my-module update --dry-run  # Preview update changes
npx my-module update-schema     # Sync Prisma schema only
npx my-module migrate           # Add version headers to old files
npx my-module uninstall         # Remove module from project
npx my-module disable           # Disable without removing files
npx my-module enable            # Re-enable a disabled module
npx my-module info              # Show module information
```

For detailed command documentation, see [Scaffold Architecture — CLI Commands](/module-starter/scaffold/#cli-commands-reference).

---

## Versioning and Updates

The module system tracks two versions and has two update flows. Getting this right is critical — it controls how your changes propagate from the module starter, through modules, and into apps.

| Version | Stored In | When to Bump |
|---------|-----------|--------------|
| **Scaffold Version** | `VERSION` file | After **any** change in the module starter repo |
| **Module Version** | `package.json` + `src/module.ts` | After changing templates in a **cloned module** |

<Aside type="caution">
**In the module starter repo, all changes are scaffold bumps.** The module version bump is only used in cloned modules. See [Versioning & Updates](/module-starter/versioning/) for the full explanation.
</Aside>

---

## Next Steps

- [Creating Modules](/module-starter/creating-modules/) - Clone and set up a new module
- [Module Structure](/module-starter/module-structure/) - Detailed file reference
- [Scaffold Architecture](/module-starter/scaffold/) - How the scaffold infrastructure works
- [Registry Integration](/module-starter/registry-integration/) - Connecting to the starter template's registries
- [Versioning & Updates](/module-starter/versioning/) - How changes propagate through the system
- [Code Templates](/module-starter/templates/) - Copy-paste templates
- [Lifecycle Hooks](/module-starter/lifecycle-hooks/) - Module lifecycle, filters, and actions
