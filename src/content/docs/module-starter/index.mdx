---
title: Module Starter Overview
description: Create distributable module packages for the starter template
---

import { Card, CardGrid, Aside, Steps } from '@astrojs/starlight/components';

The **Module Starter** is a template repository for creating installable module packages. When you clone it and customise the templates, you get a CLI tool that can scaffold features into apps built with the starter template.

<Aside type="tip">
The module starter creates **npm packages** with CLI commands like `npx my-module init`. It's not just a folder structure—it's a distribution system.
</Aside>

---

## How It Works

<Steps>
1. **Clone** the module starter to create a new module package
2. **Customise** the templates in `src/templates/`
3. **Build** with `npm run build`
4. **Distribute** via npm or direct installation
5. **Install** into apps using `npx my-module init`
</Steps>

The module starter handles all the scaffolding logic—you just write templates.

---

## Module Types

<CardGrid>
  <Card title="Frontend-Only" icon="laptop">
    Dashboard widgets, settings pages, navigation items, UI components. No backend or database required.
  </Card>
  <Card title="Fullstack" icon="rocket">
    Complete features with frontend UI, backend API routes, services, and database models.
  </Card>
</CardGrid>

---

## Package Structure

The module starter has two distinct parts:

```
module-starter/
├── src/
│   ├── module.ts           # Module configuration (EDIT THIS)
│   ├── cli.ts              # CLI entry point (DO NOT EDIT)
│   ├── scaffold/           # Scaffolding infrastructure (DO NOT EDIT)
│   │   ├── init.ts         # Installation logic
│   │   ├── update.ts       # Update logic
│   │   ├── uninstall.ts    # Uninstall logic
│   │   └── ...
│   └── templates/          # Your templates (EDIT THESE)
│       ├── schema.ts       # Prisma schema templates
│       ├── frontend/       # Frontend file templates
│       └── backend/        # Backend file templates
├── package.json            # Module package config
├── VERSION                 # Scaffold infrastructure version
└── CLAUDE.md               # AI assistant instructions
```

### What to Edit

| File | Purpose |
|------|---------|
| `src/module.ts` | Module ID, name, description, template configuration |
| `src/templates/frontend/*.ts` | Frontend file templates |
| `src/templates/backend/*.ts` | Backend file templates |
| `src/templates/schema.ts` | Prisma schema templates |
| `package.json` | Package name, version, bin command |

### What NOT to Edit

| File | Purpose |
|------|---------|
| `src/cli.ts` | CLI command handling |
| `src/scaffold/*` | Scaffolding infrastructure |

<Aside type="caution">
The scaffold files are shared infrastructure. If you find a bug, report it upstream rather than modifying locally.
</Aside>

---

## Key Concepts

### Template Placeholders

Templates use `my-feature` as a placeholder that gets replaced during installation:

| Placeholder | Replaced With | Example |
|-------------|--------------|---------|
| `my-feature` | moduleId (kebab-case) | `ai-chat` |
| `myFeature` | camelCase | `aiChat` |
| `MyFeature` | PascalCase | `AiChat` |
| `my_feature` | snake_case | `ai_chat` |

### Registry Integration

Generated code uses the app's registries to integrate without modifying core files. This is the core principle—your module registers itself with the system, rather than editing shared files.

#### Available Registries

<Tabs>
  <TabItem label="Frontend">
| Registry | What Your Module Can Register |
|----------|-------------------------------|
| `navigationRegistry` | Sidebar items (main, secondary, user menu, sections) |
| `dashboardRegistry` | Dashboard widgets |
| `settingsPagesRegistry` | New or replacement settings pages |
| `headerToolbarRegistry` | Header buttons (action, toggle, dropdown, custom) |
| `adminPagesRegistry` | Admin panel pages |
| `preferencesRegistry` | Sections on the Preferences page |
| `integrationsRegistry` | Third-party service integrations |
| `personalInfoFieldsRegistry` | Custom fields on Personal Information page |
| `notificationPreferencesRegistry` | Notification toggle options |
| `languageOptionsRegistry` | Language options |
| `filterRegistry` | Data transformation hooks (pipeline pattern) |
| `actionRegistry` | Side-effect hooks (fire-and-forget) |
  </TabItem>
  <TabItem label="Backend">
| Registry | What Your Module Can Register |
|----------|-------------------------------|
| `routeRegistry` | API routes with versioning |
| `serviceRegistry` | Services for cross-feature access |
| `filterRegistry` | Data transformation hooks |
| `actionRegistry` | Side-effect hooks |
  </TabItem>
</Tabs>

#### Example: Navigation Registration

```typescript
// Generated navigation.registration.ts
import { navigationRegistry } from '@/config/navigation.registry';
import { MessageSquare } from 'lucide-react';

navigationRegistry.registerMain({
  id: 'ai-chat',
  title: 'AI Chat',
  url: '/dashboard/ai-chat',
  icon: MessageSquare,
  order: 50,
  sidebarSection: 'tools',  // Optional: group in a sidebar section
});
```

<Aside type="note">
For a complete reference of every registry, its API, interfaces, and hooks, see [Registry Reference](/starter-template/registries/). For understanding how `BaseRegistry` works and creating custom registries, see [Base Registry Pattern](/starter-template/base-registry/).
</Aside>

#### Order Convention (0-100 Scale)

All registries use the same ordering scale. Lower numbers appear first:

| Range | Use For | Examples |
|-------|---------|----------|
| **0-25** | Primary features | Dashboard, home |
| **26-50** | Core features | Projects, documents |
| **51-75** | Secondary features | Settings, reports |
| **76-100** | Utilities | Help, admin, support |

The default order is `50` if not specified. Use `50` for most modules—admins can override via the admin panel.

### Self-Contained Schemas

Module Prisma schemas must have **no `@relation` directives**:

```prisma
// CORRECT - self-contained
model ai_chat_message {
  id        String   @id @default(cuid())
  userId    String                          // Plain FK, not a relation
  content   String
  createdAt DateTime @default(now())

  @@index([userId])
}
```

---

## CLI Commands

After building your module, these commands become available:

```bash
npx my-module init              # Install module into project
npx my-module init --force      # Overwrite existing files
npx my-module uninstall         # Remove module from project
npx my-module update            # Update to latest templates
npx my-module update --dry-run  # Preview update changes
npx my-module info              # Show module information
```

---

## Versioning and Update System

The module system has **two update flows** and **two version systems**. Understanding these is critical — they control how changes propagate from the module starter through to apps.

### How Updates Propagate

The module starter sits in the middle of a chain. Changes here flow in two directions:

```
Module Starter (this repo)
  ↓ scaffold:update (git merge via scaffold-upstream remote)
Individual Module (e.g., ai-chat-module)
  ↓ npx my-module update (template hash diffing)
App (starter template clone)
```

| Update Flow | Mechanism | What Gets Updated | Command (run in target) |
|-------------|-----------|-------------------|------------------------|
| **Module Starter → Module** | Git merge via `scaffold-upstream` remote | Scaffold infrastructure, templates, build config | `npm run scaffold:update` |
| **Module → App** | Template content hash comparison | Generated feature files in the app | `npx my-module update` |

This mirrors the starter template update pattern:

| System | Source → Target | Remote | Update Command |
|--------|----------------|--------|----------------|
| Starter Template → App | Template → App | `template-upstream` | `npm run template:update` |
| Module Starter → Module | Module starter → Module | `scaffold-upstream` | `npm run scaffold:update` |

### Two Version Systems

| Version | Stored In | When to Bump | Purpose |
|---------|-----------|--------------|---------|
| **Module Version** | `package.json` + `src/module.ts` | After changing `src/templates/*` or `src/module.ts` | Stamped into every generated file. The `update` command uses this to detect changes in apps. |
| **Scaffold Version** | `VERSION` file | After changing `src/scaffold/*` (rare) | Tracks infrastructure version. Cloned modules compare this when checking for scaffold updates. |

### Why Version Bumping Matters

Every file generated by a module gets a version header:

```typescript
// @generated-by: ai-chat v1.2.0 | hash: a3f8b2c1
```

- The **hash** is computed from the template content — `npx my-module update` compares the installed hash with the current hash to detect changes
- The **version** determines whether lifecycle hooks (like database migrations) need to run
- **If you change templates without bumping the version**, `npx my-module update` won't detect the changes and apps won't get updated files

<Aside type="caution">
**Always bump the version** after changing templates. The version controls the entire update detection mechanism. Without a bump, downstream apps will never see the changes.
</Aside>

### Version Bump Commands

All commands work cross-platform (PowerShell → Bash fallback via `scripts/run.cjs`):

```bash
# Module version — after template changes (bumps package.json + module.ts, auto-commits)
npm run version:patch    # Bug fixes (1.0.0 → 1.0.1)
npm run version:minor    # New features (1.0.0 → 1.1.0)
npm run version:major    # Breaking changes (1.0.0 → 2.0.0)

# With git tag (for publishing releases)
npm run release:patch    # Same as version:patch + creates v1.0.1 tag
npm run release:minor    # Same + creates v1.1.0 tag
npm run release:major    # Same + creates v2.0.0 tag

# Scaffold version — rare, only when editing src/scaffold/*
npm run scaffold:version:patch
npm run scaffold:version:minor
npm run scaffold:version:major
```

### Scaffold Update Commands

These commands exist in **cloned modules** (not the module starter itself) for pulling upstream changes:

```bash
npm run scaffold:check    # Preview what's changed in the module starter
npm run scaffold:update   # Merge module starter changes into this module
```

The `update-scaffold.ps1`/`.sh` scripts fetch from the `scaffold-upstream` remote and merge via git. This is how scaffold bug fixes and template improvements propagate to all modules that were cloned from the module starter.

<Aside type="note">
The create script (`create-module.ps1`/`.sh`) sets up the `scaffold-upstream` remote automatically when you clone the module starter. It renames `origin` to `scaffold-upstream` so you can add your own `origin` for your module's repository.
</Aside>

---

## Next Steps

- [Creating Modules](/module-starter/creating-modules/) - Clone and set up a new module
- [Module Structure](/module-starter/module-structure/) - Detailed file reference
- [Code Templates](/module-starter/templates/) - Copy-paste templates
- [Lifecycle Hooks](/module-starter/lifecycle-hooks/) - Filters and actions
