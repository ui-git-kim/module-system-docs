---
title: Lifecycle Hooks
description: Module lifecycle hooks and filter/action registries for advanced module integration
---

import { Aside, Tabs, TabItem } from '@astrojs/starlight/components';

This page covers two types of hooks:

1. **Module lifecycle hooks** — Code that runs during install, update, enable, disable, and uninstall
2. **Filter and action registries** — Pipeline hooks that let modules extend app behaviour at runtime

---

## Module Lifecycle Hooks

Lifecycle hooks let your module run code at key moments. Define them in your `module.ts`:

```typescript
lifecycle: {
  onInstall: async (context) => {
    // Seed initial data, create indexes
  },
  onUpdate: async (context) => {
    // Run data migrations between versions
  },
  onActivate: async (context) => {
    // Start background jobs, register webhooks
  },
  onDeactivate: async (context) => {
    // Pause jobs, unregister webhooks
  },
  onUninstall: async (context) => {
    // Offer data export, clean up external resources
  },
},
```

| Hook | When It Runs | Use Cases |
|------|-------------|-----------|
| `onInstall` | After `npx my-module init` completes | Seed initial data, create database indexes, validate config |
| `onUpdate` | When module version changes during `update` | Data migrations, deprecation handling |
| `onActivate` | After install or `enable` command | Start background jobs, register webhooks |
| `onDeactivate` | During `disable` command | Pause jobs, unregister webhooks |
| `onUninstall` | During `uninstall` command | Offer data export, clean up external resources |

<Aside type="tip">
Lifecycle hooks are optional. Most simple modules don't need them. Add them when your module needs setup beyond just generating files.
</Aside>

### Lifecycle Context

All hooks receive a context object with utilities:

```typescript
{
  cwd: string,                    // Working directory
  module: ModuleDefinition,       // Full module config
  interactive: boolean,           // Is running interactively
  utils: {
    log: {
      info: (message: string) => void,
      success: (message: string) => void,
      warning: (message: string) => void,
      error: (message: string) => void,
    },
    fileExists: (path: string) => boolean,
    readFile: (path: string) => string,
    writeFile: (path: string, content: string) => void,
    ensureDir: (path: string) => void,
    runCommand: (cmd: string) => Promise<{ stdout: string; stderr: string }>,
    prompt: (question: string, defaultValue?: string) => Promise<string>,
    confirmPrompt: (question: string, defaultValue?: boolean) => Promise<boolean>,
  },
}
```

**Install-specific context:**
- `promptAnswers` — User's responses to module prompts
- `envVariables` — Collected environment variable values

**Update-specific context:**
- `fromVersion` — Previous installed version
- `toVersion` — New version being installed
- `versionChange` — Object with `major`, `minor`, `patch` booleans indicating which segment changed
- `schemaChanged` — Whether the Prisma schema template has changed
- `moduleAnswers` — Stored prompt answers from initial installation (preserved across updates)
- `changes` — Detailed change tracking:
  - `updatedFiles` — Files that were updated
  - `addedFiles` — New files added
  - `removedFiles` — Files removed
  - `schemaUpdated` — Whether the schema was updated in this run

```typescript
onUpdate: async (context) => {
  // React to specific types of changes
  if (context.versionChange.major) {
    context.utils.log.warning('Major version update — running data migration');
    await runMigration(context.fromVersion, context.toVersion);
  }

  if (context.schemaChanged) {
    context.utils.log.info('Schema updated — you may need to run prisma migrate');
  }

  // Access original prompt answers
  const provider = context.moduleAnswers.provider || 'default';
},
```

---

## Filter & Action Registries

Modules can hook into **runtime** application events using **filters** (transform data) and **actions** (execute side effects). These are pipeline registries — available on both frontend and backend.

| Registry | Purpose | Returns Value? |
|----------|---------|----------------|
| **Filter** | Transform data at hook points | Yes — modified data |
| **Action** | Execute side effects at hook points | No — fire and forget |

<Aside type="tip">
Use **filters** when you need to modify data (e.g., format a display name).
Use **actions** when you need side effects (e.g., log an event, send a notification).
</Aside>

<Aside type="note">
For the complete API reference, see the [Filter Registry](/starter-template/registries/#filter-registry) and [Action Registry](/starter-template/registries/#action-registry) in the starter template docs.
</Aside>

---

## Filter Registry

Filters transform data as it passes through hook points. Multiple filters can chain together — each receives the output of the previous filter.

### Basic Usage

<Tabs>
  <TabItem label="Frontend">
```typescript
// filter.registration.ts
import { filterRegistry } from '@/config/filter.registry';

filterRegistry.register(
  'user.displayName',        // Hook name
  'my-feature-titles',       // Unique ID (prefix with module name)
  (name, context) => {
    if (context?.user?.title) {
      return `${context.user.title} ${name}`;
    }
    return name;
  },
  10                         // Order (lower = runs first)
);
```
  </TabItem>
  <TabItem label="Backend">
```typescript
// filter.registration.ts
import { filterRegistry } from '../../config/filter.registry.js';

// Sync filter
filterRegistry.register(
  'api.user.profile.response',
  'my-feature-mask-email',
  (profile) => ({
    ...profile,
    email: maskEmail(profile.email),
  }),
  20
);

// Async filter (for database lookups, external APIs)
filterRegistry.registerAsync(
  'api.user.profile.response',
  'my-feature-enrich',
  async (profile, ctx) => {
    const stats = await getStats(profile.id);
    return { ...profile, stats };
  },
  5
);
```
  </TabItem>
</Tabs>

### Applying Filters

```typescript
// Sync
const displayName = filterRegistry.apply('user.displayName', user.name, { user });

// Async (backend)
const response = await filterRegistry.applyAsync('api.user.profile.response', profile, ctx);

// Apply all — sync then async (backend)
const result = await filterRegistry.applyAll('hook.name', data, ctx);
```

### Filter Methods

| Method | Description |
|--------|-------------|
| `register(hook, id, fn, order?)` | Register sync filter |
| `registerAsync(hook, id, fn, order?)` | Register async filter (backend only) |
| `unregister(hook, id)` | Remove a sync filter |
| `unregisterAsync(hook, id)` | Remove an async filter (backend only) |
| `apply(hook, value, ctx?)` | Run sync filters |
| `applyAsync(hook, value, ctx?)` | Run async filters (backend only) |
| `applyAll(hook, value, ctx?)` | Run sync then async (backend only) |
| `hasFilters(hook)` | Check if any filters exist |
| `getHooks()` | List all hook names |
| `getFilterCount(hook)` | Get count of filters for a hook |
| `getFilterIds(hook)` | List filter IDs |

---

## Action Registry

Actions execute side effects at hook points. Unlike filters, they don't return values and can't modify data.

### Basic Usage

<Tabs>
  <TabItem label="Frontend">
```typescript
// action.registration.ts
import { actionRegistry } from '@/config/action.registry';

actionRegistry.addAction(
  'user.loggedIn',           // Hook name
  'my-feature-analytics',    // Unique ID
  (context) => {
    trackEvent('login', { userId: context.user.id });
  },
  10                         // Order
);

actionRegistry.addActionAsync(
  'settings.saved',
  'my-feature-sync',
  async (context) => {
    await syncToExternalService(context.settings);
  },
  20
);
```
  </TabItem>
  <TabItem label="Backend">
```typescript
// action.registration.ts
import { actionRegistry } from '../../config/action.registry.js';
import { createModuleLogger } from '../../lib/logger.js';

const log = createModuleLogger('my-feature');

actionRegistry.addAction(
  'user.created',
  'my-feature-welcome',
  (context) => {
    log.info({ userId: context.userId }, 'New user — queue welcome email');
  }
);

actionRegistry.addActionAsync(
  'user.deleted',
  'my-feature-cleanup',
  async (context) => {
    await cleanupModuleData(context.userId);
  },
  30
);
```
  </TabItem>
</Tabs>

### Triggering Actions

```typescript
// Sync only
actionRegistry.doAction('user.loggedIn', { user, method: 'email' });

// Async sequentially
await actionRegistry.doActionAsync('settings.saved', { settings });

// All — sync first, then async (backend)
await actionRegistry.doActionAll('user.created', { user, req });

// Async in parallel (backend)
await actionRegistry.doActionParallel('notifications.send', { notifications });
```

### Action Methods

| Method | Description |
|--------|-------------|
| `addAction(hook, id, fn, order?)` | Register sync action |
| `addActionAsync(hook, id, fn, order?)` | Register async action |
| `removeAction(hook, id)` | Remove an action |
| `doAction(hook, context)` | Execute sync actions |
| `doActionAsync(hook, context)` | Execute async actions sequentially |
| `doActionAll(hook, context)` | Execute sync then async (backend) |
| `doActionParallel(hook, context)` | Execute async in parallel (backend) |
| `hasActions(hook)` | Check if actions exist |
| `getHooks()` | Get all hook names |

---

## Common Hook Points

### Frontend Hooks (Planned)

Frontend hooks are not yet wired into the starter template. They will be added as concrete consumers are identified. The following are planned hook points:

| Hook | Type | When | Context |
|------|------|------|---------|
| `user.displayName` | Filter | Format display name | `{ user }` |
| `user.avatarUrl` | Filter | Modify avatar URL | `{ user }` |
| `dashboard.widgets` | Filter | Modify widget list | `{ widgets }` |
| `nav.main.items` | Filter | Modify navigation | `{ items }` |
| `user.loggedIn` | Action | After login | `{ user, method }` |
| `user.loggedOut` | Action | After logout | `{ userId }` |
| `settings.saved` | Action | After settings save | `{ settings, page }` |
| `theme.changed` | Action | After theme change | `{ theme }` |

### Backend Hooks — User Service

| Hook | Type | Execution | Context |
|------|------|-----------|---------|
| `user.created` | Action | `await doActionAll` | `{ userId, email, role, isFirstUser }` |
| `user.roleUpdated` | Action | `doAction` | `{ userId, previousRole, newRole }` |
| `user.profileUpdated` | Action | `doAction` | `{ userId, fields }` |
| `user.preferencesUpdated` | Action | `doAction` | `{ userId }` |
| `user.deleted` | Action | `await doActionAll` | `{ userId, email, deletionRecord }` |

### Backend Hooks — Admin Service

| Hook | Type | Execution | Context |
|------|------|-----------|---------|
| `admin.settingsUpdated` | Action | `doAction` | `{ settings }` |
| `admin.navigationUpdated` | Action | `doAction` | `{ overrides }` |
| `admin.toolbarUpdated` | Action | `doAction` | `{ overrides }` |
| `user.roleUpdated` | Action | `doAction` | `{ userId, previousRole, newRole, updatedBy }` |
| `user.deleted` | Action | `doAction` | `{ userId, deletedBy }` |

### Backend Hooks — Filters (Not Yet Wired)

| Hook | Type | When | Context |
|------|------|------|---------|
| `api.user.profile.response` | Filter | Before sending profile | `{ userId }` |
| `api.*.response` | Filter | Before any API response | Varies |

<Aside type="note">
Filter hooks need concrete consumers — code that calls `filterRegistry.apply()` with real data. Action hooks are wired first because they are fire-and-forget side effects. Filter hooks will be wired as the template adds data transformation points.
</Aside>

---

## Hook Naming Convention

| Pattern | Location | Examples |
|---------|----------|----------|
| `user.{property}` | Frontend | `user.displayName`, `user.avatarUrl` |
| `dashboard.{element}` | Frontend | `dashboard.widgets`, `dashboard.layout` |
| `nav.{section}.items` | Frontend | `nav.main.items`, `nav.secondary.items` |
| `api.{feature}.{action}.response` | Backend | `api.user.profile.response` |
| `service.{feature}.{method}` | Backend | `service.user.getProfile` |
| `auth.{event}` | Both | `auth.login`, `auth.failed` |

---

## Creating Custom Hooks

Modules can define their own hooks for other modules to use:

```typescript
import { filterRegistry } from '@/config/filter.registry';
import { actionRegistry } from '@/config/action.registry';

// Apply filter before returning data
export async function getFormattedData() {
  const rawData = await fetchData();
  const data = filterRegistry.apply('myModule.data.format', rawData, {
    source: 'api',
  });
  return data;
}

// Trigger action when something happens
export async function processItem(item: Item) {
  await doProcessing(item);
  await actionRegistry.doActionAsync('myModule.item.processed', {
    itemId: item.id,
    result: 'success',
  });
}
```

Document your hooks in your module's README so other developers can integrate:

```markdown
## Available Hooks

### Filters
| Hook | Purpose | Context |
|------|---------|---------|
| `myModule.data.format` | Transform data before display | `{ source }` |

### Actions
| Hook | When | Context |
|------|------|---------|
| `myModule.item.processed` | After item processing | `{ itemId, result }` |
```

---

## Best Practices

**Do:**
- Prefix IDs with your module name — `my-feature-transform` not just `transform`
- Handle errors gracefully — don't let filter/action errors break the app
- Use appropriate order values — lower = runs first, use 10-50 for most modules
- Document your hooks — help other developers integrate with your module
- Clean up on uninstall — remove filters/actions if module provides uninstall logic

**Don't:**
- Throw unhandled errors in hooks — catch and handle gracefully
- Use hooks for required logic — hooks are optional extensions
- Block async actions — keep them fast or use background jobs
- Modify the context object — create new objects instead

---

## Next Steps

- [CLI Reference](/module-starter/cli-reference/) — Full command documentation with flags and examples
- [Registry Guide](/module-starter/registry-guide/) — Register with collection registries (navigation, dashboard, etc.)
- [Code Templates](/module-starter/templates/) — Filter and action registration templates
- [Building Your Module](/module-starter/building-modules/) — Module configuration and template authoring
- [Scaffold Architecture](/module-starter/scaffold/) — How lifecycle hooks are executed during installation
