---
title: Introduction
description: What is the Module System and why use it
---

## Overview

This is a registry-based architecture for React applications. Instead of building monolithic apps, you build:

1. **A starter template** - The app foundation with registries and shell
2. **Modules** - Self-contained features that plug into the starter

## The Problem

| Issue | Traditional Approach |
|-------|---------------------|
| Features scattered across codebase | Hunt through multiple folders |
| Adding features requires modifying core code | Touch many files for one feature |
| Hard to reuse features across apps | Copy-paste and hope |
| Inconsistent patterns | Every feature structured differently |

## The Solution

| Issue | Module System Approach |
|-------|----------------------|
| Features scattered | Each module is self-contained |
| Modifying core code | Modules register themselves via registries |
| Hard to reuse | Modules install via CLI into any app |
| Inconsistent patterns | Standardised module structure |

## Core Concepts

### Registries

Registries are the glue. Instead of hardcoding navigation items, dashboard widgets, or routes, the app reads from registries. Modules register their contributions.
```typescript
// Module registers itself
navigationRegistry.register({
  id: 'billing',
  title: 'Billing',
  url: '/billing',
  icon: CreditCard,
});

// App reads from registry
const navItems = navigationRegistry.getAll();
```

### Side-Effect Imports

Modules register themselves when imported:
```typescript
// In app entry point
import '@/features/billing';  // Triggers all registrations
```

### Lifecycle Hooks

Modules define what happens at each stage:

- **onInstall** - First-time setup
- **onUpdate** - Version migrations  
- **onActivate** - Enable module
- **onDeactivate** - Disable without removing
- **onUninstall** - Full removal